1989,Organithms: the dynamics of software evolution.,"Abstract:
Summary form only given, as follows. No software system is static. A useful one evolves rapidly: the greater the number of users, the more rapid the change. How does one design for change? How does one treat specification dynamically? The issues that must be treated are local and global prototyping, rapid reconfiguring, and the control of function access and diffusion. What are the properties of an implementation language that are crucial? Why is a Lisp-based implementation language preferable to Ada? Does machine architecture play an important part? Can one separate portability from evolution?."
1986,FAC: A Functional APL Language.,"Abstract:
FAC, a functional array calculator language, features APL syntax and array operations but allows partitions, operators, and infinite arrays–extensions that are semantically wthat are semantically implausible in APL."
1985,Another View of Software (Panel).,"Before we can assess the roles and values of AI and the tools of logic in the domain of software we must be sure that we appreciate the nature of this domain. Unfortunately there is a great deal of truth to the statement “software is to the computer as life is to the planet”. Thus we know that there are many kinds of software created in many kinds of ways and serving myriad purposes. We can appreciate some of the key issues of life by examining the human being but not, in a completely satisfactory way, by examining his tools. his tools. To understand software we must go beyond the techniques and methodologies we have so carefully and painfully crafted, e.g., high level languages, structured programming, data structures and types, semaphores, functional programming, etc. Adding a few more tools will not change things very much and will probably not tell us much about why software is the way it is. Our dissatisfaction with software surfaced with operating systems and their offspring. Why? I think it was because they were created to provide an open set of services from a pool of loosely cooperating functions. Furthermore the set of services and the pool of functions would not tolerate a bound in number, intricacy of communication, and efficiency of computer use. I believe that the word “software” obscures the issues that dominate our concerns and I choose the word “organithm” to identify that class of programs we study in software engineering. Operating systems are the archetype organithms. Paraphrasing Bernal, an organithm is a partial, continuous, progressive, multiform, and conditionally interactive realization of the potentiality of human thought expressed as computer program. Thought, being what it is, an organithm is a large collection of other perhaps more limiting programs held together by useful traffic patterns. While we may say that some of the parts are perfect for their purpose, the collection is never more than adequate and thus always in a state of evolution. Supporting this evolution is the major goal of software engineering. Put another way, the dynamics of organithm development set the locus of the concerns of software engineering. Organithms model mental abstractions. As models they are approximations and never have enough state to serve as “uniform” approximants. Mental abstractions thrive on deduction and induction to increase their set of accessible states and sooner or later, like the interpolants they are, they turn sour and must change, often in unanticipated ways, in order to remain of use. So it is with the organithms that model them: Organithms are not maintained, they are reared. Like living matter they are continual consumers of energy and continual producers of waste. The creation of an organithm implies the support and act of husbandry. Thus research in the processes of organithm husbandry is, and has been, a vital concern of software engineering. Since organithms compete in their own biosphere—the computer—improvement in performance is eternally sought and, as a result, most of an organithm's state is concerned with the management of its own internals: As an organithm develops, an ever increasing concern of its logic is its own internal management and significantly, a smaller fraction of its logic is devoted to serving its external utility. Organithms tend to take advantage of their own purposes: As they develop, the internal functions of an organithm tend to maximize their use of the external functions the organithm exists to supply-this has been called closing the loop. Often these internal uses intensify traffic to such a degree that organithms are created to manage the use of the external functions, e.g., a mail system must be capable of supporting organithms that generate and read mail. Every external purpose of an organithm can be replaced by an organithmic surrogate. Since organithms are models it takes little modification for them to model unanticipated abstractions. In the course of their development organithms suggest abstractions that are both valuable and that they can support. Organithms fuel the expansion of abstract modeling as a technological activity. Unlike life, in which reproduction dominates mutation, our organithms are so simple that mutation still dominates reproduction, but this will change. A major role of AI and logic is to help in the creation of organithms that increasingly extricate us from direct involvement in the internal growth of organithms. The major issue of software engineering environments is not how to ease our task of programming systems but how to accelerate the rate at which improvement in internal function can be obtained without unduly jeopardizing the external functions of an organithm and with maximizing the use of organithms to perform reorganization. Insofar as AI and logic support autonomy in these activities of development and response will they be of value in the software enterprise."
1982,A Syntax-Free Semantics for the APL Operators.,n/a
1982,Epigrams on Programming.,n/a
1979,Social Processes and Proofs of Theorems and Programs.,"It is argued that formal verifications of programs, no matter how obtained, will not play the same key role in the development of computer science and software engineering as proofs do in mathematics. Furthermore the absence of continuity, the inevitability of change, and the complexity of specification of significantly many real programs make the formal verification process difficult to justify and manage. It is felt that ease of formal verification should not dominate program language design."
1977,Social Processes and Proofs of Theorems and Programs.,"It is argued that formal verifications of programs, no matter how obtained, will not play the same key role in the development of computer science and software engineering as proofs do in mathematics. Furthermore the absence of continuity, the inevitability of change, and the complexity of specification of significantly many real programs make the formal verification process difficult to justify and manage. It is felt that ease of formal verification should not dominate program language design."
1969,Identifying and developing curricula in software engineering.,One basis for developing an education program is the recognition of a continuing need for a certain class of professionals in our society.
1967,A proposal for definitions in ALGOL.,"One of the most important problems in computer development today is the difficult job of constructing programs and programming languages to handle a wide variety of tasks. There are two pure approaches to programming language design and an endless number of mixed approaches lying between them. One of the pure approaches, often taken by graduate students in universities, is to create a new programming language for each problem. The other approach, perhaps typified by certain supporters of PL/I, is to design a language which is intended hopefully to be all things to all programmers. Unfortunately, neither of these pure approaches is really practical. People have long recognized the common features of programming problems and most agree that certain techniques are applicable to almost all of them. However, with the burgeoning use of the machine it is not possible to assert with any degree of confidence that we have discovered all useful techniques. A reasonable way to proceed seems to be to design a programming language which contains most of the common features which people have discovered in various problems, but which allows the user to extend and mold the language to suit his particular application."
1967,The Synthesis of Algorithmic Systems.,n/a
1966,A new policy for algorithms?,"Debate is under way concerning the Algorithms section of the Communications. Specifically, there is considerable sentiment in favor of also publishing algorithms in languages other than ALGOL."
1964,A format language.,"One of the most primitive parts of a formula language is its specification of input-output actions within the framework of the language. While the specification is intrinsically more complex, say, than the evaluation of an arithmetic expression, most of the difficulties associated with input-output specification arise from the fact that the desired operations have not been properly defined using the framework of a programming language. Indeed, the complexity largely disappears when a programming language is constructed to specify input-output actions. The point to be made here is that the definition of an appropriate programming language makes more rational and simpler all three phases of the input-output programming cycle: (i) source program construction, (ii) object program construction, (iii) object program execution."
1964,An extension to ALGOL for manipulating formulae.,n/a
1964,Programming of digital computers.,n/a
1964,How should ACM publish computer research?,n/a
1963,Revised report on the algorithm language ALGOL 60.,n/a
1963,Computation's development critical to our society.,"The ACM's growth continues: we are now at 13,000 members; expenses also grow. Our professional membership does not spring from a uniformly trained group as in mathematics or physics or even economics. Instead, our increasing membership comes from what I might call intellectual adventures—pioneers in an over-organized society—who see great futures in computing at all levels of aspiration."
1963,Revised report on the algorithmic language ALGOL 60.,n/a
1962,Compiling matrix operations.,"It is unfortunate that almost all of the presently used algebraic languages do not provide the capability of linear algebra. Operations such as the inner product of vectors, the product of two matrices, and the multiplication of a matrix by a scaler must inevitably be written out in detail in terms of the individual components. The reasons usually given for avoiding linear algebra in these languages are (1) the difficulties which would arise in scanning linear algebraic expressions, and (2) the uncertainty involved as to the amount of temporary storage needed during the evaluation of linear algebraic expressions when the program is executed. The purpose of this paper is to show how these two types of difficulties can be overcome. Although suggestions have been made for even further increasing the general capability of ALGOL such as including the ability to form a matrix from a collection of vectors, we shall be content here to consider the ordinary operations of linear algebra. Even if this much becomes available in algebraic languages, considerable progress will have been made. The following remarks constitute a suggestion for the addition to ALGOL of linear algebraic expressions."
1961,The use of threaded lists in constructing a combined ALGOL and machine-like assembly processor.,n/a
1960,Symbol Manipulation by Threaded Lists.,n/a
1960,Report on the algorithmic language ALGOL 60.,n/a
1959,A Visit to Computation Centers in the Soviet Union.,n/a
1959,ALGOL Sub-Committee Report - Extensions.,n/a
1959,ACM Publication Policies and Plans.,n/a
1959,Report on the Algorithmic Language ALGOL the ACM committee on programming languages and the GAMM committee on programming.,n/a
1959,Symposium on automatic programming.,n/a
1958,Preliminary Report-International Algebraic Language.,n/a
