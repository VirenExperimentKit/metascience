1990,Addition Machines.,"It is possible to compute gcd $(x, y)$ efficiently with only $O(\log xy)$ additions and subtractions, when three arithmetic registers are available but not when there are only two. Several other functions, such as $x^y \bmod z$, are also efficiently computable in a small number of registers, using only addition, subtraction, and comparison."
1982,The Compilation of Regular Expressions into Integrated Circuits.,"The design of integrated circuits to implement arbitrary regular expressions is considered. In general, a regular expression with n operands may be converted into a nondeterministic finite automaton with at most n states and n transitions. Instead of converting the nondeterministic device to a deterministic one, two ways of implementing the nondeterministic device directly are proposed. One apporach is to produce a PLA (programmable logic array) of approximate dimensions n rows and 2n columns by representing the states of the nondeterministic finite automaton directly by columns. This approach, while theoretically suboptimal, makes use of carefully developed technology and, because of the care with which PLA implementation has been done, may be the preferred technique in many real situations. Another approach is to use the hierarchical structure of the automaton produced from the regular expression by the McNaughton-Yamada algorithm to guide a hierarchical layout of the circuit. This method produces a circuit on a side and is, to within a constant factor, the best that can be done in general."
1980,The Compilation of Regular Expressions into Integrated Circuits (Extended Abstract).,"Abstract:
We consider the design of integrated circuits to implement arbitrary regular expressions. In general, we may use the McNaughton-Yamada algorithm to convert a regular expression of length n into a nondeterministic finite automaton with at most 2n states and 4n transitions. Instead of converting the nondeterministic device to a deterministic one, we propose two ways of implementing the nondeterministic device directly. First, we could produce a PLA (programmable logic array) of approximate dimensions 4n × 4n by representing the states directly by columns, rather than coding the states in binary. This approach, while theoretically suboptimal, makes use of carefully developed technology and, because of the care with which PLA implementation has been done, may be the preferred technique in many real situations. Another approach is to use the hierarchical structure of the automaton produced from the regular expression to guide a hierarchical layout of the circuit. This method produces a circuit 0(√n) on a side and is, to within a constant factor, the best that can be done in general."
1979,The Paradigms of Programming.,"Today I want to talk about the paradigms of programming, how they affect our success as designers of computer programs, how they should be taught, and how they should be embodied in our programming languages.

This article is summarized in: the morning paper
an interesting/influential/important paper from the world of CS every weekday morning, as selected by Adrian Colyer"
1978,Exact and Approximate Membership Testers.,"In this paper we consider the question of how much space is needed to represent a set. Given a finite universe U and some subset V (called the vocabulary), an exact membership tester is a procedure that for each element s in U determines if s is in V. An approximate membership tester is allowed to make mistakes: we require that the membership tester correctly accepts every element of V, but we allow it to also accept a small fraction of the elements of U - V."
1975,Expected Time Bounds for Selection.,"A new selection algorithm is presented which is shown to be very efficient on the average, both theoretically and practically. The number of comparisons used to select the ith smallest of n numbers is n + min(i,n-i) + o(n). A lower bound within 9 percent of the above formula is also derived."
1975,The Algorithm SELECT - for Finding the ith Smallest of n Elements [M1] (Algorithm 489).,"SELECT will rearrange the values of array segment X[L: R] so that X[K] (for some given K; L ≤ K ≤ R) will contain the (K-L+1)-th smallest value, L ≤ I ≤ K will imply X[I] ≤ X[K], and K ≤ I ≤ R will imply X[I] ≥ X[K. While SELECT is thus functionally equivalent to Hoare's algorithm FIND [1], it is significantly faster on the average due to the effective use of sampling to determine the element T about which to partition X. The average time over 25 trials required by SELECT and FIND to determine the median of n elements was found experimentally to be: n 500 1000 5000 10000 SELECT 89 ms. 141 ms. 493 ms. 877 ms. FIND 104 ms. 197 ms. 1029 ms. 1964 ms. The arbitrary constants 600, .5, and .5 appearing in the algorithm minimize execution time on the particular machine used. SELECT has been shown to run in time asymptotically proportional to N + min (I, N-I), where N = L - R + 1 and I = K - L + 1. A lower bound on the running time within 9 percent of this value has also been proved [2]. Sites [3] has proved SELECT terminates."
1975,The Exact Time Required to Perform Generalized Addition.,
1973,A Linear Time Two Tape Merge.,n/a
1973,Time Bounds for Selection.,"The number of comparisons required to select the i-th smallest of n numbers is shown to be at most a linear function of n by analysis of a new selection algorithm—PICK. Specifically, no more than 5.4305 n comparisons are ever required. This bound is improved for extreme values of i, and a new lower bound on the requisite number of comparisons is also proved."
1972,An Interpretation-Oriented Theorem Prover over Integers.,A special purpose theorem prover for establishing the validity of expressions over integer variables was developed as part of a program verifier. It is built around a powerful system for manipulating and simplifying integer expressions.
1972,Permuting Information in Idealized Two-Level Storage.,"Abstract
Assume a computer with a (relatively) slow and large memory consisting of pages, each with a capacity of p records. Available operations for manipulating information in slow memory are limited to selecting two pages, forming a subset, of size at most p, from the union of the two pages, and storing this subset in a third page."
1972,Linear Time Bounds for Median Computations.,"New upper and lower bounds are presented for the maximum number of comparisons, f(i,n), required to select the i-th largest of n numbers. An upper bound is found, by an analysis of a new selection algorithm, to be a linear function of n: f(i,n) ≤ 103n/18 < 5.73n, for 1 ≤ i ≤ n. A lower bound is shown deductively to be: f(i,n) ≥ n+min(i,n−i+l) + [log2(n)] − 4, for 2 ≤ i ≤ n−1, or, for the case of computing medians: f([n/2],n) ≥ 3n/2 − 3"
1971,"Notes on Avoiding ""go to"" Statements.",n/a
1971,Toward Interactive Design of Correct Programs.,"This chapter describes an imagined interaction between a computer programmer and his machine, which might be made feasible within the next decade. It focuses on an intelligent assistant approach. The chapter also presents the earliest published description of an intelligent programming assistant. It describes an imagined interaction between a computer programmer and an intelligent program verifier assistant; such systems will be feasible within the following decade. The programmer is at an interactive console, designing a program, first in its overall outline, then by successive developments in detail. The computer is, of course, serving its customary role as syntactic analyzer, code generator, program executor, prompter, and file handler. In addition, the computer is continually checking the program, at each level of specification, for consistency with the programmer's stated intentions"
1970,An Interpretation Oriented Theorem Prover over Integers.,A special purpose theorem prover for establishing the validity of expressions over integer variables was developed as part of a program verifier. It is built around a powerful system for manipulating and simplifying integer expressions.
1967,Nondeterministic Algorithms.,"Programs to solve combinatorial search problems may often be simply written by using multiple-valued functions. Such programs, although impossible to execute directly on conventional computers, may be converted in a mechanical way into conventional backtracking programs. The process is illustrated with algorithms to find all solutions to the eight queens problem on the chessboard, and to find all simple cycles in a network."
1964,Bounded context syntactic analysis.,"Certain phase structure grammars define languages in which the phrasehood and structure of a substring of a sentence may be determined by consideration of only a bounded context of the substring. It is possible to determine, for any specified bound on the number of contextual characters considered, whether a given grammar is such a bounded context grammar. Such grammars are free from syntactic ambiguity. Syntactic analysis of sentences in a bounded context language may be performed by a standard process and requires a number of operations proportional to the length of sentence analyzed. Bounded context grammars form models for most languages used in computer programming, and many methods of syntactic analysis, including analysis by operator precedence, are special cases of bounded context analysis."
1964,Algorithm 245: Treesort.,n/a
1964,The Syntax of Programming Languages-A Survey.,"Abstract:
The syntactic rules for many programming languages have been expressed by formal grammars, generally variants of phrase-structure grammars. The syntactic analysis essential to translation of programming languages can be done entirely mechanically for such languages. Major problems remain in rendering analyzers efficient in use of space and time and in finding fully satisfactory formal grammars for present and future programming languages."
1963,Syntactic Analysis and Operator Precedence.,"Three increasingly restricted types of formal grammar are phrase structure grammars, operator grammars and precedence grammars. Precedence grammars form models of mathematical and algorithmic languages which may be analyzed mechanically by a simple procedure based on a matrix representation of a precedence relation between character pairs."
1962,Algorithm 96: Ancestor.,n/a
1962,Algorithm 97: Shortest path.,n/a
1962,Algorithm 113: Treesort.,n/a
1962,On the nonexistence of a phrase structure grammar for ALGOL 60.,"ALGOL 60 is defined partly by formal mechanisms of phrase structure grammar, partly by informally stated restrictions. It is shown that no formal mechanisms of the type used are sufficient to define ALGOL 60."
1962,On ambiguity in phrase structure languages.,n/a
1961,An algorithm for coding efficient arithmetic operations.,"Most existing formula translation schemes yield inefficient coding. A method is described which reduces the number of store and fetch operations, evaluates constant sub-expressions during compilation, and recognizes many equivalent subexpressions."
1961,A Note on Mathematical Induction on Phrase Structure Grammars.,"Two rules of derivation are exhibited and shown to yield valid metalinguistic theorems concerning phrase structure grammars (type 2 or context-free grammars, in Chomsky's notation)."
1961,A Descriptive Language for Symbol Manipulation.,n/a
1960,An Algorithm Defining ALGOL Assignment Statements.,"It is not possible, by testing symbol pairs only [2], to determine whether a given symbol string is consistent with the formation rules of ALGOL [1]. For example, the formula l1: l2: x[i := 5j + 3.14.159; violates four distinct formation rules of ALGOL, yet each pair of adjacent characters may appear in permissible formulae. The algorithm described here will determine, with minor restrictions, whether a particular symbol string is a permissible ALGOL assignment statement. I believe that the same technique may be extended to determine whether a given symbol string is a permissible ALGOL program or not, where a program is defined as a sequence of permissible statements separated by semicolons. The algorithm scans the formula from left to right, replacing certain character pairs by single characters. If under the allowable transformations the symbol string may be reduced to the single character &Sgr;, it is a well-formed formula in ALGOL; otherwise it violates the formation rules."
1960,Note of amplification.,n/a
