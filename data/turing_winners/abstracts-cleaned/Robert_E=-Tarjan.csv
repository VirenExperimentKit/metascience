2019,randomized concurrent set union generalized wake-up,consider disjoint set union problem asynchronous shared memory multiprocessor computation model design randomized algorithm performs work per operation  performs + log total work expectation problem instance operation n element solved p process algorithm first work bound grow sublinearly p adversarial schedulerwe use jayantis wake problem newly defined generalized wake problem prove several lower bound concurrent set union show ω expected work lower bound cost single operation set union algorithm show single-operation upper bound optimal across algorithm p = nω furthermore identify class symmetric algorithm capture complexity known algorithm disjoint set union problem prove ω + log expected total work lower bound algorithm class thereby showing algorithm optimal total work complexity class finally prove randomized algorithm symmetric cannot breach ω + log log expected total work lower bound
2019,simple concurrent labeling algorithm connected component,present new concurrent labeling algorithm finding connected component study theoretical efficiency even though many algorithm proposed many experiment done algorithm simpler obtain step bound two algorithm using novel multi-round analysis conjecture algorithm also take step able prove bound also point gap previous analysis similar algorithm  show even basic problem like connected component still secret reveal
2019,new path splay dynamic optimality,consider task performing sequence search binary search tree search algorithm allowed arbitrarily restructure tree cost proportional amount restructuring performed cost execution sum time spent searching time spent optimizing search restructuring operation notion introduced sleator tarjan   along algorithm conjecture algorithm splay elegant procedure performing adjustment moving searched item top tree conjecture called dynamic optimality cost splaying always within constant factor optimal algorithm performing search conjecture stand daywe offer first systematic proposal settling dynamic optimality conjecture heart method term simulation embedding mapping execution list key induces target algorithm simulate execution build simulation embedding splay inducing perform arbitrary subtree transformation use show cost splaying sequence item upper bound cost splaying every subsequence thereof splay dynamically optimal call subsequence property building machinery show splay dynamically optimal respect optimal cost additive overhead linear sum initial tree size number request corollary subsequence property also necessary condition dynamic optimality subsequence property also implies traversal  deque  conjecturesthe notion simulation embeddings bounding additive overhead general interest competitive analysis reader especially interested dynamic optimality provide outline proof lower bound search cost wilber  subsequence property extensive suggestion adapting proof splay
2019,splaying preorders postorders,let binary search tree n node root r left subtreel=leftl right subtreer=rightr preorder postorder defined follows preorder postorder empty tree empty sequence andpreorderpostorder=⊕preorder⊕preorder=postorder⊕postorder⊕where⊕denotes sequence concatenation  prove following  behavior splaying  preorders postordersinserting node preorder empty tree via splaying cost  inserting node postorder empty tree via splaying cost  ift′thas key weight-balanced  splaying either preorder postorder starting fromt′tcosts    use fact preorders postorders pattern-avoiding ie contain subsequence order-isomorphic   respectively pattern-avoidance implies certain constraint manner item inserted exploit structure simple potential function count inserted node lying access path uninserted node method likely extended permutation avoid general pattern proof  us fact preorders postorders balanced search tree contain many large “jumps” symmetric order exploit fact using dynamic finger theorem  item   novel item  originally proved chaudhuri höft  proof simplifies  provide evidence favor elusive dynamic optimality conjecture 
2019,zip tree,introduce zip tree  form randomized binary search tree integrates previous idea one practical performant pleasant-to-implement package zip tree binary search tree node numeric rank tree -heap-ordered respect rank tie broken favor smaller key zip tree essentially treaps  except rank drawn geometric distribution instead uniform distribution allow rank tie change enable u use fewer random bit per nodewe perform insertion deletion unmerging merging path  rather rotation avoids pointer change improves efficiency method zipping unzipping take inspiration previous top-down approach insertion deletion stephenson  martínez roura  sprugnoli theoretical standpoint work provides two main  first zip tree require onlyoobits  represent largest rank n-node binary search tree previous data structure requireoobits largest rank second zip tree naturally isomorphic skip list  simplify dean jones’ mapping skip list binary search tree 
2017,minimum-cost flow unit-capacity network,consider combinatorial algorithm minimum-cost flow problem network unit capacity special case problem historically researcher developed special-purpose algorithm exploit unit capacity contrast maximum flow problem classical blocking flow push-relabel algorithm general case also best bound known special case unit capacity paper show classical blocking flow push-relabel cost-scaling algorithm goldberg tarjan  general minimum-cost flow problem achieve best known bound unit-capacity problem well also develop cycle-canceling algorithm extends goldberg shortest path algorithm  minimum-cost unit-capacity flow problem finally combine idea obtain algorithm solves minimum-cost bipartite matching problem    time number edge c largest arc cost  r number vertex small side vertex bipartition result generalizes  result duan et al  solves open problem ramshaw tarjan 
2017,hollow heap,introduce hollow heap simple data structure amortized efficiency classical fibonacci heap heap operation except delete delete-min take time worst case well amortized delete delete-min take amortized time heap n item hollow heap simplest structure achieve bound hollow heap combine two novel idea use lazy deletion re-insertion decrease-key operation use dag  instead tree set tree represent heap lazy deletion produce hollow node  giving data structure name
2016,amortized rotation cost avl tree,resolved open problem performance avl tree term rotations•n mixed insertion deletion causerotations•we show class avl tree allow expensive operation
2016,dominator tree certification divergent spanning tree,one verify output complicated program correct one formally prove program correct may beyond power existing method alternatively one check output produced particular input satisfies desired input--output relation running checker input--output pair one need prove correctness checker problem however even checker may complicated formally verify third alternative augment original program produce output also correctness certificate property simple program  use certificate verify input--output pair satisfies desired input--output relationwe consider following important instance general question one verify dominator tree flow graph correct existing fast algorithm finding dominators complicated even verifying correctness dominator tree absence additional information seems complicated define correctness certificate dominator tree show use easily verify correctness tree show augment fast dominator-finding algorithm produce correctness certificate also relate dominator certificate problem problem finding divergent spanning tree flow graph develop algorithm find tree algorithm run linear time previous algorithm apply special case trivial dominators take least quadratic time
2016,new approach incremental cycle detection related problem,consider problem detecting cycle directed graph grows arc insertion related problem maintaining topological order strong component graph problem give two algorithm one suited sparse graph dense graph former take time insert arc n-vertex graph latter take time sparse algorithm substantially simpler previous o-time algorithm also faster graph sufficient density time bound dense algorithm beat previously best time bound dense graph algorithm rely efficiency vertex numbering weakly consistent topological order allow tie bound size number give bound running time
2016,deletion without rebalancing binary search tree,address vexing issue deletion balanced tree rebalancing deletion generally complicated rebalancing insertion textbook neglect deletion rebalancing many b-tree--based database system describe relaxation avl tree rebalancing done insertion deletion yet worst-case access time remains logarithmic number insertion application balanced tree number update polynomial tree size structure offer performance competitive classical balanced tree addition periodic rebuilding performance structure theoretically superior many classic balanced tree structure structure need lg lg m+  bit balance information per node number insertion lg base-two logarithm lg lg n+ periodic rebuilding n number node insertion take two rotation amortized time counting time find insertion position standard avl tree using analysis relies exponential potential function show rebalancing step occur frequency exponentially small height affected node technique apply type balanced tree notably b-trees show companion article particularly red-black tree viewed special case b-trees
2016,randomized concurrent algorithm disjoint set union,disjoint set union basic problem data structure wide variety application extend known efficient sequential algorithm problem obtain simple efficient concurrent wait-free algorithm running asynchronous parallel random access machine  crucial result use randomization certain independence assumption problem instance n element operation l process algorithm θ + log  expected work expectation random choice made algorithm α functional inverse ackermanns function addition operation take step high probabilitywe point gap earlier work problem anderson woll  importantly algorithm significantly simpler finally independence assumption algorithm achieves speedup close linear application process kept busy thereby partially answering open problem posed
2015,rank-balanced tree,since invention avl tree  many kind binary search tree proposed notable red-black tree bottom-up rebalancing insertion deletion take amortized time rotation worst-case design space balanced tree fully explored continue exploration contribution three systematically study use rank rank difference define height-based balance binary tree different invariant rank difference yield avl tree red-black tree kind balanced tree relaxing avl tree obtain new kind balanced binary tree weak avl tree  whose property develop bottom-up rebalancing insertion deletion take amortized time two rotation improving three rotation per deletion needed kind balanced tree aware height bound wavl tree degrades gracefully avl tree number deletion increase never worse red-black tree wavl tree also support top-down fixed look-ahead rebalancing amortized time finally use exponential potential function prove wavl tree rebalancing step occur exponentially infrequently rank thus rebalancing bottom tree crucial concurrent application rotation take time depends subtree size
2015,faster dynamic maximum flow incremental breadth-first search,introduce excess incremental breadth-first search  algorithm maximum flow problem show excess ibfs best overall practical performance real-world instance maintaining polynomial running time guarantee ibfs generalizes application video object segmentation require solving series maximum flow problem slightly different previous excess ibfs naturally extends dynamic setting competitive practice dynamic method
2015,minimum cost flow graph unit capacity,consider minimum cost flow problem graph unit capacity special case previous study special purpose algorithm exploiting fact capacity one developed contrast maximum flow unit capacity best bound proven slight modification classical blocking flow push-relabel algorithm paper show classical cost scaling algorithm goldberg tarjan  applied problem unit capacity achieve improve best known bound weighted bipartite matching establish bound slight variation algorithm r size smaller side bipartite graph number edge c largest absolute value arc-cost simplifies result  improves bound answering open question  graph unit vertex capacity establish novel bound also give first cycle canceling algorithm minimum cost flow unit capacity algorithm naturally generalizes single source shortest path algorithm 
2014,efficient maximum flow algorithm,though maximum flow algorithm long history revolutionary progress still made
2014,cb tree practical concurrent self-adjusting search tree,present cb tree counting-based self-adjusting binary search tree splay tree more-frequently accessed item move closer root sequential execution    operation   c  access item   v  access   v  traverse path length    rotation unlike original splay tree access move accessed item way root via sequence rotation access cb tree rotation specifically    sequence    operation   n  insertion     amortized per operation   mn  adapt cb tree scalable concurrent self-adjusting bst show experimentally concurrent cb tree scale well performs rotation therefore self-adjusts without rotation create bottleneck evaluation show concurrent cb tree performs better existing concurrent search tree non-uniform access sequence derived real workload
2014,deletion without rebalancing multiway search tree,database system use form b-tree underlying data structure rebalancing deletion mean bad sequence deletion create unbalanced tree yet database perform well practice avoidance rebalancing deletion justified empirically average-case analysis knowledge worst-case analysis done analysis show tree height remains logarithmic number insertion independent number deletion furthermore amortized time insertion deletion excluding search time node modified insertion deletion frequency exponentially small height latter  hold standard b-trees adding periodic rebuilding tree obtain data structure theoretically superior standard b-trees many way  suggest rebalancing deletion unnecessary may harmful
2014,back-to-basics empirical study priority queue,theory community proposed several new heap variant recent past remained largely untested experimentally take field back drawing board straightforward implementation classic novel structure using standard well-known optimization study behavior structure variety input including artificial workload workload generated running algorithm real map data workload discrete event simulator used recent system networking research provide observation characteristic correlated performance example find l cache miss rate appears strongly correlated wallclock time also provide observation input sequence affect relative performance different heap variant example show  certain random insertion-deletion sequence degenerate lead misleading  overall finding suggest conventional wisdom hold case sorely mistaken others
2014,nested set union,consider version classic disjoint set union  problem two partition element rather one restricted one partition refinement call nested set union problem problem occurs new algorithm find dominators flow graph one solve problem using two instance data structure classical problem natural ask whether instance combined show answer yes nested problem solved extending classic solution support two nested partition cost bit storage per element small constant overhead running time solution extends handle constant number nested partition
2014,disjoint set union randomized linking,classic result analysis data structure path compression linking rank solves disjoint set union problem almost-constant amortized time per operation recent experiment suggest practice nave linking method work well better linking rank spite theoretically inferior prove randomized linking asymptotically efficient linking rank result provides theory match experiment implicitly randomized linking result way input instance generated
2014,better approximation algorithm graph diameter,diameter fundamental graph parameter computation necessary many application fastest known way compute diameter exactly solve all-pairs shortest path  problemin absence fast algorithm attempt made seek fast algorithm approximate diameter seminal result aingworth chekuri indyk motwani  designed algorithm computes  time estimate  diameter directed graph nonnegative edge weight        maximum edge weight graph recent work roditty vassilevska w  gave la vega algorithm approximation guarantee improves  runtime  roditty vassilevska w also showed unless strong exponential time hypothesis fails  time algorithm sparse unweighted undirected graph achieve approximation ratio better  thus algorithm essentially tight sparse unweighted graph weighted graph however approximation guarantee meaningless arbitrarily largein paper exhibit two algorithm achieve genuine -approximation diameter one running  time one running  time furthermore algorithm deterministic thus present first deterministic -approximation algorithm diameter take subquadratic time sparse graphsin addition address question obtaining additive c-approximation diameter ie estimate   c    extremely simple  time algorithm achieves additive n-approximation better  known show  >  getting additive n-approximation algorithm diameter running  time  >  would falsify strong exponential time hypothesis thus simple algorithm probably essentially tight sparse graph moreover obtaining subquadratic time additive c-approximation constant c unlikelyfinally consider problem computing eccentricity vertex undirected graph ie largest distance vertex roditty vassilevska w  show  time one compute v  v undirected graph estimate  eccentricity  max {r   }    min {d   } r = minv  radius graph improve approximation guarantee showing variant algorithm achieve estimate        
2014,loop nesting forest dominators application,loop nesting forest dominator tree important tool program optimization code generation application diverse area work first present carefully engineered implementation efficient algorithm computing loop nesting forest given directed graph including efficient algorithm computes forest single depth-first search revisit problem computing dominators present efficient implementation algorithm recently proposed fraczak et al  include algorithm acyclic graph algorithm computes dominator tree loop nesting forest also propose new algorithm combine algorithm fraczak et al acyclic graph algorithm lengauer tarjan finally provide fast algorithm following related problem computing bridge testing -edge connectivity verifying dominators testing -vertex connectivity computing low-high order two independent spanning tree exhibit efficiency algorithm experimentally large graph taken variety application area
2013,finding dominators via disjoint set union,problem finding dominators directed graph many important application notably global optimization computer code although linear near-linear-time algorithm exist use sophisticated data structure develop algorithm finding dominators us “static tree” disjoint set data structure addition simple list map algorithm run near-linear linear time depending implementation disjoint set data structure give several version algorithm including one computes loop nesting information  made self-certifying correctness computed dominators easy verify
2013,soft heap simplified, chazelle  pp -- introduced new kind meldable heap  called soft heap soft heap trade accuracy speed heap operation allowed increase key certain item thereby making item bad long number bad item data structure $ m$ $m$ total number insertion performed far $$ error parameter amortized time per heap operation $o$ reduced $o$ $n$ number item heap chazelle used soft heap several application including faster deterministic minimum-spanning-tree algorithm new deterministic linear-time selection algorithm give simplified implementation soft heap us le space avoids chazelles dismantling operation also give simpler improved analysis yield amortized time bound $o$ deletion $o$ operation
2013,dominator certification independent spanning tree experimental study,present first implementation certified algorithm computing dominators exhibit efficiency experimentally graph taken variety application area certified algorithm obtained augmenting dominator-finding algorithm compute certificate correctness easy verify suitable certificate dominators obtained concept low-high order independent spanning tree therefore implementation provide efficient construction concept well interesting right furthermore present experimental study efficient algorithm computing dominators large graph
2012,optimal dynamic data structure stabbing-semigroup query,let set n interval ${r}$ let $$ commutative semigroup assign weight $  {s}$ interval point $x  {r}$ let $s  s$ set interval contain x given point $q  {r}$ stabbing-semigroup query asks computing ${s  s} $ propose linear-size dynamic data structure pointer-machine model answer query worst-case $o$ time support insertion deletion interval amortized $o$ time first data structure attains optimal $o$ bound three operation furthermore structure easily adapted external memory obtain linear-size structure answer query support update $o$ i/os b disk block size restricted case nested family interval  present simpler solution based dynamic tree
2012,incremental cycle detection topological ordering strong component maintenance,present two online algorithm maintaining topological order directed n-vertex acyclic graph arc added detecting cycle one created first algorithm handle arc addition time sparse graph  bound improves best previous bound logarithmic factor tight within constant factor among algorithm satisfying natural locality property second algorithm handle arbitrary sequence arc addition time sufficiently dense graph bound improves best previous bound polynomial factor bound may far tight show algorithm take ω time relating performance generalization k-levels problem combinatorial geometry completely different algorithm running θ time given recently bender fineman gilbert extend algorithm maintenance strong component without affecting asymptotic time bound
2012,algorithmic view universe,year since alan turing following lead computer scientist advanced understanding computational phenomenon developing specialized original penetrating way rigorous thinking turn algorithmic way thinking applied productively study important phenomenon outside computation proper  development exquisite unintended consequence fact latent computation underlying phenomenon way science study
2012,weight-scaling algorithm min-cost imperfect matchings bipartite graph,call bipartite graph g =  balanced |x| = |y | given balanced bipartite graph g edge cost assignment problem asks perfect matching g minimum total cost hungarian method solve assignment problem time n = |x| = |y | = |e| edge weight integer bounded magnitude c >  algorithm using weight scaling gabow tarjan lower time important application g unbalanced |x| ≠ |y | require min-cost matching size r = min generally specified size ≤ r hungarian method extends easily find matching time weightscaling algorithm extend easily introduce new machinery find matching time via weight scaling  provide insight design space efficient weight-scaling matching algorithm
2012,dominators directed bipolar order independent spanning tree,consider problem related dominators independent spanning tree flowgraphs provide linear-time algorithm solution introduce notion directed bipolar order generalizing previous notion plein cheriyan reif show construct order information computed several known algorithm finding dominators show concurrently verify correctness dominator tree directed bipolar order simply construct two spanning tree whose path disjoint except common dominators finally describe alternative way verify dominators without using directed bipolar order
2012,strict fibonacci heap,present first pointer-based heap implementation time bound matching fibonacci heap worst case support make-heap insert find-min meld decrease-key worst-case time delete delete-min worst-case time n size heap data structure us linear spacea previous complicated solution achieving time bound ram model made essential use array extensive use redundant counter scheme maintain balance solution us neither key simplification discard structure smaller heap meld use pigeonhole principle place redundant counter mechanism
2012,cbtree practical concurrent self-adjusting search tree,present cbtree new counting-based self-adjusting binary search tree like splay tree move frequently accessed node closer root operation n item c access item v operation v traverse path lengthologmcowhile performing rotation contrast traditional self-adjusting splay tree accessed item moved root sequence tree rotation cbtree performs rotation infrequently  per operation m ≫ n mostly bottom tree result cbtree scale amount concurrency adapt cbtree multicore setting show experimentally improves performance compared existing concurrent search tree non-uniform access sequence derived real workload
2011,rank-pairing heap,introduce rank-pairing heap implementation heap combine asymptotic efficiency fibonacci heap much simplicity pairing heap heap implementation match bound fibonacci heap maintaining balance condition tree representing heap contrast structure like pairing heap tree evolve arbitrary  structure also like pairing heap structure requires one cut restructuring per key decrease worst case change cascade key decrease change node rank although data structure simple analysis
2011,data structure mergeable tree,motivated application computational geometry consider novel variant problem efficiently maintaining forest dynamic rooted tree variant includes operation merges two tree path contrast standard problem single operation add delete one arc one merge add delete linear number arc spite develop three different method need polylogarithmic time per operation first method extends solution farach thorup  special case path merge take amortized time n-node forest standard dynamic tree operation take time latter bound amortized worst case randomized depending underlying data structure special case occurs motivating application arbitrary arc deletion  occur give method take time per operation including merging best possible model computation ω lower bound sorting n number since sorting done tree operation even-more-special case cut parent query give method us standard dynamic tree black box mergeable tree operation becomes constant number standard dynamic tree operation third method also used motivating application changing algorithm application three method need different analytical tool reveals different property dynamic tree
2011,maximum flow incremental breadth-first search,maximum flow minimum s-t cut algorithm used solve several fundamental problem computer vision problem special structure standard technique perform worse special-purpose boykov-kolmogorov  algorithm introduce incremental breadth-first search  method us idea bk augments shortest path ibfs theoretically justified  usually outperforms bk vision problem
2011,theory v practice design analysis algorithm,talk i’ll explore gap theoretical study algorithm use algorithm practice example drawn experience industry academia include data structure network algorithm based example i’ll try draw help guide work theoretician experimentalists effort make work relevant need practitioner
2010,hp transforms product portfolio management operation research,hewlett-packard  offer many innovative product meet diverse customer need breadth product offering helped company achieve unparalleled market reach however come significant cost challenge offering multiple similar product manufacturer increase overall demand volatility reduces forecast accuracy adversely affect revenue cost across entire product life cycle hp impact included increase inventory-driven cost order-cycle time liability channel partner cost operation research development marketing administration furthermore complexity hp product line confused customer sale representative channel partner sometimes driving business competitor hp developed two powerful operation research-based solution managing product variety first framework screening new product us custom-built return-on-investment  calculator evaluate proposed new product introduction meet threshold roi level targeted exclusion proposed lineup second hp revenue coverage optimization  tool based fast new maximum-flow algorithm used manage product variety introduction identifying core portfolio product important order coverage rco enables hp business increase operational focus critical product tool enabled hp increase profit across business unit $ million since  moreover hp streamlined product offering improved execution achieved faster delivery lowered overhead increased customer satisfaction market share
2010,deletion without rebalancing balanced binary tree,address vexing issue deletion balanced tree rebalancing deletion generally complicated rebalancing insertion textbook neglect deletion rebalancing many database system describe relaxation avl tree rebalancing done insertion deletion yet access time remains logarithmic number insertion many application balanced tree structure offer performance competitive classical balanced tree addition periodic rebuilding performance structure theoretically superior many classic balanced tree structure structure need bit balance information per node number insertion periodic rebuilding n number node insertion take two rotation amortized time using analysis relies exponential potential function show rebalancing step occur frequency exponentially small height affected node
2009,shortest-path feasibility algorithm experimental evaluation,experimental study algorithm shortest-path feasibility problem given directed weighted graph find negative cycle present short proof none exists study previously known new algorithm testbed extensive previously used including static incremental problem well worst-case instance show single algorithm dominates small subset  robust performance practice work advance state art area
2009,dynamic tree practice,dynamic tree data structure maintain forest change time edge insertion deletion besides maintaining connectivity information logarithmic time support aggregation information path tree perform experimental comparison several version dynamic tree st-trees et-trees rc-trees two variant top tree  quantify strength weakness test various workload stemming practical application observe simple linear-time implementation remarkably fast graph small diameter worst-case randomized data structure best query frequent best overall performance however achieved self-adjusting st-trees
2009,efficiently generating k-best solution procurement auction,procurement executive often find difficult articulate preference constraint regarding auction making difficult cast procurement decision straightforward optimization problem paper present efficient algorithm aid decision support situation instead trying compute single optimal solution auction winner determination problem generate many candidate solution ascending order buyer expenditure standard technique clustering dominance pruning trim list compact yet diverse menu alternative analysis illuminate cost constraint competitive landscape efficient solution-generation algorithm address sealed-bid procurement auction multiple supplier multiple type good available multiple unit support multi-sourcing volume discounts/surcharges bid algorithm may optionally incorporate certain class hard constraint generating solution satisfy
2009,experimental study minimum mean cycle algorithm,study algorithm minimum mean cycle problem parametric version shortest path feasibility  three basic approach problem cycle-based binary search tree-based first two use spf algorithm subroutine latter us parametric approach implementing spf-based method one choice spf algorithm incremental optimization strategy also several way handle precision issue lead dozen variant systematically compare experimental setup comprehensive previous study experiment tree-based method two implementation cycle-based method outperformed approach including binary search
2008,planarity algorithm via pq-trees extended abstract,give abstract vertex-addition method planarity testing encompasses algorithm lempel even cederbaum shih hsu boyer myrvold main difference former latter two order vertex addition latter two differ implementation detail general method give direct proof correctness avoids use kuratowskis theorem give linear-time implementation simplifies unifies shih-hsu boyer-myrvold method algorithm extends generate embeddings uniformly random count embeddings represent embeddings produce kuratowski subgraph non-planar graph algorithm keep track possible embeddings reinterpreting booth luekers pq-tree data structure represent circular instead linear order interpretation pq-trees give pc-trees shih hsu lead simpler more-symmetric form pq-tree reduction
2008,finding strongly knit cluster social network,social network ubiquitous discovery closely knit cluster network fundamental practical interest existing clustering criterion limited cluster typically overlap vertex clustered and/or external sparsity ignored introduce new criterion overcomes limitation combining internal density external sparsity natural way paper explores combinatorial property internally dense externally sparse cluster simple algorithm given provably finding cluster assuming sufficiently large gap internal density external sparsity exoerimental  show algorithm able identify  cluster real graph assuming condition external sparsity
2008,finding feasible flow strongly connected network,give linear-time algorithm find feasible flow strongly connected network fixed supply demand summing common value minimum arc capacity algorithm speed goldberg–rao maximum flow method constant factor
2008,linear-time algorithm dominators path-evaluation problem,present linear-time algorithm classic problem finding dominators flowgraph several problem whose solution require evaluating function defined path tree although problem linear-time solution previously algorithm simpler case substantially improvement come three new idea refined analysis path compression give linear bound compression favor certain node replacement random-access table look-up radix sort careful partitioning tree easily managed part addition finding dominators algorithm find nearest common ancestor off-line verify construct minimum spanning tree interval analysis flowgraph build component tree weighted tree algorithm require power random-access machine run linear time pointer machine genesis work discovery subtle error analysis previous allegedly linear-time algorithm finding dominators algorithm attempt simplify complicated algorithm intended correct error yet earlier algorithm work provides systematic study subtlety dominators problem technique needed solve linear time range application resulting method tried make technique simple general possible understand exactly earlier approach dominators problem either incorrect overly complicated
2008,thin heap thick heap,fibonacci heap devised provide especially efficient implementation dijkstras shortest path algorithm although asyptotically efficient fast practice heap implementation expanding idea høyer  describe three heap implementation  amortized efficiency fibonacci heap need le space promise better practical performance part development fill gap høyers analysis
2008,shortest path feasibility algorithm experimental evaluation,experimental study algorithm shortest path feasibility problem given directed weighted graph find negative cycle present short proof none exists study previously known new algorithm testbed extensive previously used including static incremental problem well worst-case instance show single algorithm dominates small subset  robust performance practice work advance state art area
2008,faster algorithm incremental topological ordering,present two online algorithm maintaining topological order directed acyclic graph arc added detecting cycle one created first algorithm take amortized time per arc second algorithm take amortized time per arc n number vertex total number arc sparse graph bound improves best previous bound factor logn tight within constant factor natural class algorithm includes existing one main insight two-way search method previous algorithm require ordered search general allowing u avoid use heap  instead deterministic version algorithm us  median-finding randomized version algorithm us uniform random sampling dense graph bound improves best previously published bound factor n / recent bound obtained independently work factor logn main insight graph search wasteful graph dense avoided searching topological order space instead algorithm extend maintenance strong component asymptotic time bound
2008,reachability problem directed graph,present recent work open problem two directed graph reachability problem one dynamic one static dynamic problem detect creation cycle directed graph arc added much progress made recently problem intriguing question remain static problem compute dominators related information flowgraph problem solved solution complicated related problem well understood work discussed colleague researcher speaker
2008,fast exact heuristic method role minimization problem,describe several new bottom-up approach problem role engineering role-based access control  salient problem np-complete even approximate yet find instance arise practice problem solved minute first consider role minimization process finding smallest collection role used implement pre-existing user-to-permission relation introduce fast graph reduction allow recovery solution solution problem smaller input graph test case reduction either solve problem reduce problem enough find optimum solution  exponential method introduce lower bound sharp seven nine test case within  two introduce test new polynomial-time approximation average yield  role optimum next consider related problem minimizing number connection role user permission develop effective heuristic method problem well finally propose method several related problem
2007,server allocation algorithm tiered system,many web-based system tiered application architecture request need transverse tier finishing processing one important qos metric application expected response time user since expected response time tier depends upon number server allocated tier request total response time sum response time tier many different configuration  satisfy expected response-time requirement naturally one would like find configuration minimizes total system cost satisfying total response-time requirement modeled non-linear optimization problem using open-queuing network model response time call server allocation problem tiered system  paper study computational complexity sapts design efficient algorithm solve variable number tier show decision version sapts np-complete design simple two-approximation algorithm fully polynomial-time approximation scheme  number tier constant show sapts polynomial-time solvable furthermore design fast polynomial-time exact algorithm solve important two-tier case  extend general case tier arbitrary response-time function
2007,clustering social network,social network ubiquitous discovery close-knit cluster network fundamental practical interest existing clustering criterion limited cluster typically overlap vertex clustered and/or external sparsity ignored introduce new criterion overcomes limitation combining internal density external sparsity natural way algorithm given provably finding cluster provided sufficiently large gap internal density external sparsity experiment real social network illustrate effectiveness algorithm
2007,experimental evaluation parametric max-flow algorithm,parametric maximum flow problem extension classical maximum flow problem capacity certain arc fixed function single parameter gallo et al  showed certain version push-relabel algorithm ordinary maximum flow extended parametric problem increasing worst-case time bound constant factor recently zhang et al  proposed novel simple balancing algorithm parametric problem bipartite network claimed good performance algorithm network arising real-world application describe  experimental study comparing performance balancing algorithm ggt algorithm simplified version ggt algorithm network related application zhang et al well network designed hard balancing algorithm implementation balancing algorithm beat version ggt algorithm network related application thus supporting observation zhang et al hand ggt algorithm robust beat balancing algorithm natural network asymptotically increasing amount network designed hard balancing algorithm
2006,finding dominators practice,computation dominators flowgraph application several area including program optimization circuit testing theoretical biology lengauer tarjan  proposed two version fast algorithm finding dominators compared experimentally iterative bit-vector algorithm concluded version algorithm much faster even graph moderate size recently cooper et al  proposed new simple tree-based implementation iterative algorithm experiment suggested faster simple version lengauer-tarjan algorithm graph representing computer program control flow motivated work cooper et al present experimental study comparing algorithm  careful implementation version lengauer-tarjan algorithm new hybrid algorithm  suggest although performance algorithm similar consistently fast simple lengauer-tarjan algorithm hybrid algorithm advantage increase graph get bigger complicated
2006,melding priority queue,show priority queue data structure support insert delete find-min operation pq amortized time n upper bound number element priority queue converted priority queue data structure also support fast meld operation essentially increase amortized cost operation specifically new data structure support insert meld find-min operation amortized time delete operation + α amortized time α functional inverse ackermann function n time total number operation performed priority queue construction simple meldable priority queue obtained placing nonmeldable priority queue node union-find data structure also show key integer range  replace n bound stated previously min{n n}applying result nonmeldable priority queue data structure obtained recently thorup  han thorup  obtain meldable ram priority queue amortized time per operation expected amortized time per operation respectively by-product obtain improved algorithm minimum directed spanning tree problem graph integer edge weight namely deterministic o-time algorithm randomized o-time algorithm sparse enough graph bound improve running time algorithm gabow et al  work arbitrary edge weight
2006,balancing applied maximum network flow problem,explore balancing definitional algorithmic tool finding minimum cut maximum flow ordinary parametric network show standard monotonic parametric maximum flow problem formulated problem computing particular maximum flow balanced appropriate sense present divide-and-conquer algorithm compute balanced flow logarithmic number ordinary maximum-flow computation special case bipartite network present two simple local algorithm computing balanced flow local balancing idea becomes even simpler applied ordinary maximum flow problem problem present round-robin arc-balancing algorithm computes maximum flow n-vertex m-arc network integer arc capacity u time although algorithm slower least factor n known algorithm extremely simple well-suited parallel distributed implementation
2006,design data structure mergeable tree,motivated application computational topology consider novel variant problem efficiently maintaining dynamic rooted tree variant allows operation merges two tree path contrast standard problem one tree arc time change single merge operation change many arc spite develop data structure support merges standard tree operation amortized time n-node forest special case occurs motivating application arbitrary arc deletion allowed give data structure amortized time bound per operation asymptotically optimal analysis algorithm straightforward requires idea previously used study dynamic tree explore design space algorithm problem also consider lower bound
2006,result problem self-adjusting search tree related data structure,splay tree form self-adjusting search tree invented almost  year ago splay tree remarkably efficient theory practice many question concerning splay tree related data structure remain open foremost among dynamic optimality conjecture state amortized efficiency splay tree optimum within constant factor among kind binary search tree splay tree constant-competitive broader question whether form binary search tree constant-competitive recently three different group researcher devised kind search tree loglog-competitive improving log-competitiveness balanced tree least one data structure multisplay tree many nice asymptotic property splay tree  review recent work look remaining open problem many including resolving question whether splay tree loglog-competitive
2005,deadline scheduling animation rendering,n/a
2005,dominator tree verification vertex-disjoint path,present linear-time algorithm given flowgraph g =  tree check whether dominator tree g also prove exist two spanning tree g vertex <u>v</u> path r <u>v</u> intersect vertex dominate <u>v</u> proof constructive algorithm build two spanning tree linear time simpler version two algorithm run o-time n number vertex number arc g existence two spanning tree implies order calculation iterative algorithm finding dominators proposed allen cocke  build dominator tree single iteration
2005,self-adjusting top tree,dynamic tree problem maintaining forest change time edge insertion deletion associate data vertex edge manipulate data individually bulk operation deal whole path tree efficient solution problem numerous application particularly algorithm network flow dynamic graph general several data structure capable logarithmic-time dynamic tree operation proposed first sleator tarjans st-tree  represents partition tree path although reasonably fast practice adapting st-trees different application nontrivial topology tree  top tree  rc-trees  based tree contraction progressively combine vertex edge obtain hierarchical representation tree approach flexible theory known implementation assume tree bounded degree arbitrary tree supported ternarization show two approach combined  produce data structure generic easy adapt practical st-trees
2005,value-maximizing deadline scheduling application animation rendering,describe new class utility-maximization scheduling problem precedence constraint disconnected staged scheduling problem  dssp nonpreemptive multiprocessor deadline scheduling problem arises several commercially-important application including animation rendering protein analysis seismic signal processing dssp differs previously-studied deadline scheduling problem graph precedence constraint among task within job disconnected one component per job another difference practice often lack accurate estimate task execution time purely offline solution possible however know set job precedence constraint front therefore offline planning possibleour solution decomposes dssp offline job selection phase followed online task dispatching phase model former knapsack problem explore several solution describe new dispatching algorithm latter compare existing method theoretical  show dssp np-hard inapproximable general two-phase scheduling method guarantee good performance bound many special case empirical  include evaluation scheduling algorithm real animation-rendering workload present characterization workload companion paper workload record eight week activity -cpu cluster used render portion full-length animated feature film shrek   show improved scheduling algorithm substantially increase aggregate value completed job compared existing practice new task dispatching algorithm lcpf performs well several metric including job completion time well aggregate value completed job
2004,finding dominators revisited extended abstract,problem finding dominators flowgraph arises many kind global code optimization setting  lengauer tarjan gave almost-linear-time algorithm find dominators  harel claimed linear-time algorithm algorithm incomplete alstrup et al  gave complete simpler linear-time algorithm random-access machine  buchsbaum et al claimed new simpler linear-time algorithm implementation random access machine pointer machine paper begin noting key lemma buchsbaum et al fact apply algorithm algorithm run linear time provide complete correct simpler linear-time dominators algorithm one key result linear-time reduction dominators problem nearest common ancestor problem implementable either random-access machine pointer machine
2003,graph clustering minimum cut tree,paper introduce simple graph clustering method based minimum cut within graph clustering method general enough apply kind graph well suited graph link structure implies notion reference similarity endorsement web citation graph show quality produced cluster bounded strong minimum cut expansion criterion also develop framework hierarchical clustering present application real-world data conclude clustering algorithm satisfy strong theoretical criterion perform well practice
2003,dynamic rectangular intersection priority,present efficient data structure maintain dynamic set rectangle priority assigned efficiently find rectangle maximum priority containing query point data structure support insertion deletion rectangle one dimension rectangle interval efficient data structure support query insertion time deletion time requires linear space interval guaranteed nonoverlapping  obtain simpler data structure support operation time
2002,union-find deletion,classical union-find problem maintain partition universe n element disjoint set subject operation union find operation union replaces set b partition union given name c operation find return name set containing element x paper revisit union-find problem context underlying partitioned universe fixed specifically allow delete operation remove element x set containing consider worst-case performance amortized performance setting challenge dynamically keep size structure representing set proportional number element set may decrease result deletionsfor fixed k describe data structure support find delete worst-case time union worst-case time match best possible worst-case bound find union classical setting furthermore using incremental global rebuilding technique obtain reduction converting union-find data structure union-find deletion data structure reduction time bound find union change constant factor time take delete element x time take find set containing x plus time take unite singleton set setin amortized setting classical data structure tarjan support sequence find n union universe n element time α = min{k | ak > l} ai ackermanns function described  refine analysis data structure show fact cost find proportional size corresponding set specifically show one pay sequence union find operation charging constant participating element find element set size l also show keep amortized cost find participating element allowing deletion amortized cost deleting element set l element amortized cost finding element namely
2002,meldable heap boolean union-find,classical meldable heap data type maintain item-disjoint collection heap operation find-min insert delete decrease-key meld usual definition decrease-key delete get item heap containing parameter consider modified problem decrease-key delete get item heap containing show problem one operation find-min decrease-key meld must take non-constant time contrast original data type data structure supporting three operation constant time known establish  meldable heap consider weaker version union-find problem independent interest call boolean union-find boolean union-find problem find operation binary predicate get item x set answer positively &khgr &egr prove lower bound hold union-find cell probe model hold boolean union-find wellwe also suggest new heap data structure implementing modified meldable heap data type based redundant binary counter data structure good worst-case bound best data structure match worst-case lower bound establish problem simplest data structure interesting generalization binomial queue
2001,unique maximum matching algorithm,consider problem testing uniqueness maximum matchings unweighted weighted case unweighted case two  first given graph n vertex edge test whether graph unique perfect matching find exists time algorithm us recent dynamic connectivity algorithm old result kotzig characterizing unique perfect matchings term bridge special case planar graph improve algorithm run time second given one perfect matching test existence another linear time algorithm modification edmonds blossom-shrinking algorithm implemented using depth-first search generalization kotzigs theorem proved jackson whitty allows u give modification first algorithm test whether given graph unique f-factor find exists also show modify second algorithm check whether given f-factor unique extension time bound perfect matching counterpart weighted case test linear time whether maximum-weight matching unique given output edmonds algorithm computing matching method extension algorithm unweighted case
2001,dynamic self-checking technique improved tamper resistance,describe software self-checking mechanism designed improve tamper resistance large program mechanism consists number tester redundantly test change executable code running report modification mechanism built compatible copy-specific static watermarking tamper-resistance technique mechanism includes several innovation make stealthy robust
2001,faster kinetic heap use broadcast scheduling,describe several implementation kinetic heap heap  key item instead fixed linear function time kinetic heap simple example kinetic data structure kind considered basch guibas hershberger kinetic heap many application computational geometry previous implementation designed address application describe additional application broadcast scheduling kinetic heap implementation improves previous implementation simpler asymptotically faster application
2000,simple confluently persistent catenable list,consider problem maintaining persistent list subject concatenation insertion deletion end update persistent data structure nondestructive---each operation produce new list incorporating change keeping intact list list applies although general technique exist making data structure persistent technique fail structure subject operation catenation combine two version paper develop simple implementation persistent double-ended queue  catenation support deque operation constant amortized time implementation functional allow memoization
1999,tractability parameterized completion problem chordal strongly chordal proper interval graph,study parameterized complexity three np-hard graph completion problemsthe minimum fill-in problem asks graph triangulated adding k edge develop algorithm problem graph n vertex edge f exponential k constant hidden big-o notation small depend k particular implies problem fixed-parameter tractable proper interval graph completion problem motivated molecular biology asks graph made proper interval adding k edge show problem fpt providing simple search-tree-based algorithm solves o-time similarly show parameterized version strongly chordal graph completion problem fpt giving o-time algorithm itall algorithm actually enumerate possible k-completions within time bound
1999,tight analysis two local load balancing algorithm,paper present analysis following load balancing algorithm step node network examines number token neighbor sends token neighbor least d+ fewer token maximum degree node network show within $o$ step algorithm reduces maximum difference token two node $o/$ $$ global imbalance token  n number node network $$ edge expansion network time bound tight sense graph edge expansion $$ value $$ exists initial distribution token imbalance $$ time reduce imbalance even $/$ least $$ bound final imbalance tight sense exists class network locally balanced everywhere  global imbalance remains $ / $ furthermore show upon reaching state global imbalance $o/$ time algorithm locally balance network large $$ extend analysis variant algorithm dynamic asynchronous network also present tight bound randomized algorithm node sends one token step
1999,faster simpler algorithm sorting signed permutation reversal,give quadratic time algorithm finding minimum number reversal needed sort signed permutation algorithm faster previous algorithm hannenhalli pevzner faster implementation berman hannenhalli algorithm conceptually simple require special data structure study also considerably simplifies combinatorial structure used analysis
1998,culturally induced information impactedness prescription failure software venture,impact effective information flow software venture analyzed recent case hot lucrative technology lost way marketplace failure occurred despite fact venture many component crucial success including proprietary intellectual property position enormous market demand well-qualified committed team sufficient funding one reason failure lack information flow among several party critical success venture case suggests software market operate breakneck pace short development cycle effective information flow first-order priority blockage information flow stem nature culture created produce software idea especially proprietary technology case also suggests information affected clash u software market characteristic japanese business culture fortunately inexpensive solution substantially improve return investment especially foreign investment new software technology
1998,robustness security digital watermark,digital watermarking nascent promising technology offer protection unencrypted digital content paper brief technical survey multimedia watermarking landscape three main technical challenge faced watermarking algorithm fidelity robustness security current watermarking method offer possibly acceptable fidelity robustness certain type processing data compression noise addition sufficiently robust geometric transforms scaling cropping image theoretical approach developed could lead secure watermarking method substantial gap remain theory practice
1998,culturally-induced information impactedness prescription failure software venture,impact effective information flow software venture analyzed recent case hot lucrative technology lost way marketplace failure occurred despite fact venture many component crucial success including proprietary intellectual property position enormous market demand well-qualified committed team sufficient funding one reason failure lack information flow among several party critical success venture case suggests software market operate breakneck pace short development cycle effective information flow first order priority blockage information flow stem nature culture created produce software idea especially proprietary technology case also suggests information become impacted clash u software market characteristic japanese business culture fortunately inexpensive solution substantially improve return investment especially foreign investment new software technology
1998,simple confluently persistent catenable list extended abstract,consider problem maintaining persistent list subject concatenation insertion deletion end update persistent data structure nondestructive-each operation produce new list incorporating change keeping intact list list applies although general technique exist making data structure persistent technique fail structure subject operation catenation combine two version paper develop simple implementation persistent double-ended queue catenation support deque operation constant amortized time
1997,optimal parallel verification minimum spanning tree logarithmic time,present first optimal parallel algorithm verification sensitivity analysis minimum spanning tree algorithm deterministic run ino time require linear-work crew pram model algorithm used subroutine linear-work randomized algorithm finding minimum spanning tree cole klein tarjan
1997,toward efficient unstructured multigrid preprocessing,multigrid method general powerful mean accelerating convergence discrete iterative method solving partial differential equation  similar problem adaptation multigrid method un structured mesh important solving problem complex geometry problem lie forefront many scientific engineering field unfortunately multi grid scheme unstructured mesh require signifi cantly preprocessing structured mesh fact preprocessing major part solution task many application must executed repeatedly addition large computational requirement real istic pdes accurately discretized unstructured mesh make computation candidate parallel distributed processing add problem partitioning preprocessing task propose examine experi mentally automatic unified strategy perform several unstructured multigrid preprocessing task strategy based dominating set unstructured mesh also suggest several alternative related strategy experiment evaluate performance two preprocessing task coarse-mesh generation domain partitioning experiment suggest preprocessing strategy produce high-quality mesh give good multigrid performance strategy also pro duce domain partition reasonably load bal anced relatively small edge cut overall conclude simple integrated algorithmic strategy data structure make tedious preprocessing task efficient automateda necessary step toward practical application unstructured multigrid method
1997,dynamic tree search tree via euler tour applied network simplex algorithm,thedynamic tree abstract data type allows maintenance collection tree subject joining adding edge  splitting deleting edge  time allowing reporting certain combination vertex edge value many application dynamic tree value must combined along path application value must combined entire tree latter situation idea used originally parallel graph algorithm represent tree euler tour lead simple implementation time per tree operation wheren number tree vertex apply representation implementation two version network simplex algorithm resulting time per pivot wheren number vertex problem network
1997,faster simpler algorithm sorting signed permutation reversal,give quadratic time algorithm finding minimum number reversal needed sort signed permutation algorithm faster previous algorithm hannenhalli pevzner faster implementation berman hannenhalli algorithm conceptually simple require special data structure study also considerably simplifies combinatorial structure used analysis 
1996,dominating set planar graph,motivated application unstructured multigrid calculation consider problem asymptotically minimizing size dominating set triangulated planar graph specifically wish find smallestεsuch fornsufficiently large everyn-vertex planar graph contains dominating set size mostεnwe prove /<ε</ conjecture thatε=/for triangulated disc obtain tight bound ofε=/the upper bound proof yield linear-time algorithm finding an-size dominating set
1996,parallelism multigrid method much much,multigrid method powerful technique accelerate solution computationally-intensive problem arising broad range application used conjunction iterative process solving partial differential equation multigrid method speed iterative method moving computation original mesh covering problem domain series coarser mesh hierarchical structure leaf domain-parallel version standard multigrid algorithm deficiency parallelism coarser grid compensate several parallel multigrid strategy parallelism also work designed examine parallel strategy compare simpler standard algorithm try determine technique efficient practical consider three parallel multigrid strategy  domain-parallel version standard v-cycle f-cycle algorithm  multiple coarse grid algorithm proposed fredrickson mcbryan generates several coarse grid fine grid  two rosendale algorithm allow computation grid simultaneously study elliptic model problem simple domain discretized finite difference technique block-structured mesh two three dimension   point respectively analyze performance using three model parallel computation pram two bridging model bridging model reflect salient characteristic two kind parallel computer simd fine-grain computer contain large number small  processor spmd medium-grain computer modest number powerful  processor analysis suggests standard algorithm substantially efficient algorithm utilizing either parallel strategy parallel strategy need much extra work compensate extra parallelism require highly impractical number processor competitive simpler standard algorithm analysis also suggests f-cycle appropriate optimization technique efficient v-cycle broad range problem implementation machine characteristic despite fact exhibit even le parallelism v-cycle
1996,analysis multigrid algorithm massively parallel computer architectural implication,study potential performance multigrid algorithm running massively parallel computer intent discovering whether currently envisioned machine provide efficient platform algorithm algorithm substantially improve performance iterative method solving partial differential equation consider domain parallel version standard v-cycle multigrid algorithm model problem discretized using finite difference technique two three dimension block-structured grid size  respectively develop set model parallel computation reflect computing characteristic current generation massively parallel multicomputers model based interconnection network   message passing “workstation size” processor executing spmd mode model based computing characteristic architectural class provide metric balance abstraction machine specificity medium grain parallelism current generation high fixed cost interprocessor communication analysis suggests efficient implementation practical problem size requires machine support efficient transmission long message  otherwise high initiation cost communication must significantly reduced alternative optimization technique analysis also suggests low diameter multistage network provide little advantage simple single stage communication network finally analysis suggests fine grain parallelism low fixed communication cost may provide efficiency medium grain parallelism low variable communication cost
1996,toward efficient unstructured multigrid preprocessing extended abstract,multigrid method general powerful mean accelerating convergence discrete iterative method solving partial differential equation  similar problem adaptation multigrid method unstructured mesh important solution problem complex geometry unfortunately multigrid scheme unstructured mesh require significantly preprocessing structured mesh fact preprocessing major part solution task many application must done repeatedly addition large computational requirement realistic pdes accurately discretized unstructured mesh make computation candidate parallel distributed processing adding problem partitioning preprocessing taskwe report project apply idea graph theory geometry solution preprocessing task required parallel implementation unstructured multigrid method objective provide conceptually simple efficient unified method previous conference paper proposed two bottom-up graph-based method one top-down method paper report several set experiment designed explore practical aspect one method based independent dominating set experiment studied empirical property mesh hierarchy generated method numerical performance multigrid method solving laplace equation using mesh hierachies experiment also studied domain partition generated method  based preliminary experiment simple automatic method provide excellent multigrid performance low preprocessing cost
1996,finding minimum spanning forest logarithmic time linear work using random sampling,describe randomized crcw pram algorithm find minimum spanning forest n-vertex graph time linear work shave factor best previous running time linear-work algorithm novelty approach divide computation two phase first find partial solution idea used previously parallel connected component algorithm
1996,purely functional representation catenable sorted list,power purely functional programming construction data structure received much attention functional language many desirable property structure built purely functionally automatically fully persistent version structure coexist indefinitely recent  illustrate surprising power pure functionality one result development representation double-ended queue catenation support operation including catenation worst-case constant time paper continuation study pure functionality especially relates persistence purpose purely functional data structure one built lisp function car const cdr explore purely functional representation sorted list implemented finger search tree describe three implementation efficient achieves logarithmic access insertion deletion time double-logarithmic catenation time us one level structural bootstrapping obtain efficiency bound access insert delete best known bound ephemeral implementation operation using finger search tree representation present first address issue persistence pure functionality first fast implementation catenation split presented simple implement could efficient practice especially application require worst-case time bound persistence
1995,lazy structure sharing query optimization,study lazy structure sharing tool optimizing equivalence testing complex data type investigate number strategy implementing lazy structure sharing provide upper lower bound performance  case strategy applied restricted case problem bound provide nontrivial improvement naïve linear-time equivalence-testing strategy employ optimization one strategy however employ path compression seems promising general case problem
1995,randomized linear-time algorithm find minimum spanning tree,present randomized linear-time algorithm find minimum spanning tree connected graph edge weight algorithm us random sampling combination recently discovered linear-time algorithm verifying minimum spanning tree computational model unit-cost random-access machine restriction operation allowed edge weight binary comparison
1995,confluently persistent deques via data-structural bootstrapping,introduce data-structural bootstrapping technique design data structure recursively use design confluently persistent deques data structure requires worst-case time space per deletion k total number deque operation constant worst-case time space operation data structure allows purely functional implementation side effect improves previous result driscoll sleator tajan 
1995,data-structural bootstrapping linear path compression catenable heap-ordered double-ended queue,deque heap order linear list element real-valued key allows insertion deletion element end list also allows findmin  operation return element least  key allow general deletemin  operation data structure also called mindeque  whereas implementing heap-ordered deques constant time per operation solved problem catenating heap-ordered deques sublogarithmic time remained open nowthis paper provides efficient implementation catenable heap-ordered deques yielding constant amortized time per operation important algorithmic technique employed idea call data-structural bootstrapping abstract heap-ordered deques representing minimum element thereby reducing catenation simple insertion efficiency resulting data structure depends upon complexity special case path compression prove take linear time
1995,computing minimal spanning subgraphs linear time,let p property undirected graph consider following problem given graph g property p find minimal spanning subgraph g property p describe general algorithm problem prove correctness fairly weak assumption p establish worst-case running time algorithm $$ -edge-connectivity biconnectivity n denote number vertex edge respectively input graph refining basic algorithm obtain first linear time algorithm computing minimal -edge-connected spanning subgraph computing minimal biconnected spanning subgraph also devise general algorithm computing minimal spanning subgraph directed graph algorithm allow u simplify earlier algorithm gibbon karp ramachandran soroker tarjan computing minimal strongly connected spanning subgraph also provide first tight analysis latter algorithm showing worst-case time complexity $$
1995,model parallel computation survey synthesis,realm sequential computing random access machine successfully provided underlying model computation promoted consistency coordination among algorithm developer computer architect language expert realm parallel computing however similar success need unifying parallel model set model heightened greater demand performance greater diversity among machine yet modeling parallel computing still seems mired controversy chaos paper present broad range model parallel computation different role serve algorithm language machine design objective better understand model characteristic important design community order elucidate requirement unifying paradigm impetus discussion conclude suggesting model parallel computation consistent model design philosophy balance simplicity descriptivity prescriptivity present survey abstract computational model introduction provide insight rich array relevant issue disciplines< >
1995,persistent list catenation via recursive slow-down,n/a
1994,fully persistent list catenation,paper considers problem representing stack catenation stack old new available access update operation problem arises implementation list-based functional programming language solution proposed requiring constant time space stack operation except catenation requires time space k number stack operation done catenation resource bound amortized sequence operation
1994,faster deterministic maximum flow algorithm,cheriyan hagerup developed randomized algorithm compute maximum flow graph n node edge expected time randomization used efficiently play certain combinatorial game arises computation give version algorithm general version game arises give strategy game yield deterministic algorithm computing maximum flow directed graph n node edge run time algorithm give deterministic algorithm m/n = ω positive constant ϵ currently fastest deterministic algorithm computing maximum flow long m/n = ω
1994,unique binary-search-tree representation equality testing set sequence,paper study problem representing set ordered universe unique binary search tree dictionary operation performed efficiently set although efficient randomized solution problem known deterministic complexity open paper exhibit representation permit execution dictionary operation optimal deterministic time dictionary sufficiently sparse sufficiently dense  demonstrate exponential separation deterministic randomized complexity problemunique representation applied obtain efficient data structure maintaining dynamic collection sets/sequences query test equality pair object data structure set equality testing test equality set constant time process set update $o$ amortized time $o$ space denotes total number update performed based efficient implementation cascade con operation uniquely stored s-expressions data structure sequence equality testing test equality sequence constant time process update $o$ amortized time $o$ amortized space n denotes length sequence updated denotes total number update performed
1994,dynamic perfect hashing upper lower bound,dynamic dictionary problem considered provide algorithm storing dynamic set allowing operation insert delete lookup dynamic perfect hashing strategy given randomized algorithm dynamic dictionary problem take $o$ worst-case time lookup $o$ amortized expected time insertion deletion us space proportional size set stored furthermore lower bound time complexity class deterministic algorithm dictionary problem proved class encompasses realistic hashing-based scheme use linear space algorithm amortized worst-case time complexity $ $ sequence n insertion lookup worst-case lookup time restricted k lower bound becomes $ $
1994,improved algorithm bipartite network flow,paper network flow algorithm bipartite network studied network $g = $ called bipartite vertex set v partitioned two subset $v_ $ $v_ $ edge one endpoint $v_ $ $v_ $ let $n = |v|$ $n_ = |v_ |$  $n_ = |v_ |$ $m = |e|$ assume without loss generality $n_  n_ $ bipartite network called unbalanced $n_  n_ $ balanced otherwise  shown several maximum flow algorithm substantially sped applied unbalanced network basic idea improvement two-edge push rule allows one charge computation vertex $v_ $ hence develop algorithm whose running time depend $n_ $ rather n example shown two-edge push version goldberg tarjans fifo preflow-push algorithm run $o$ time analogous version ahuja orlins excess scaling algorithm run $o$ time u largest edge capacity idea also extended dynamic tree implementation parametric maximum flow minimum-cost flow
1994,tractability parameterized completion problem chordal interval graph minimum fill-in physical mapping,study parameterized complexity several np-hard graph completion problem minimum fill-in problem decide graph triangulated adding k edge develop algorithm problem graph n vertex edge particular implies problem fixed parameter tractable  proper interval graph completion problem motivated molecular biology ask adding edge order obtain proper interval graph parameter graph exceed k show problem fpt k number added edge problem k clique size give on/sup k-/ algorithm polynomial fixed k hand prove hardness parameterized hierarchy probably fpt  obtained even set edge added given set given either explicitly proper vertex coloring added edge respect< >
1994,unstructured multigrid strategy massively parallel computer case integrated design,multigrid technique used successfully practice speed convergence computationally intensive pde iterative solution scheme instead iterating termination accuracy fine grid multigrid algorithm move computation among hierarchy grid adapting structured multigrid technique unstructured mesh hierarchy requires substantial increase preprocessing task mesh generation discretization construction inter-mesh transfer operator addition current generation medium-grained parallel supercomputer requires set good domain partition efficient parallel execution present three practical strategy efficiently accomplish preprocessing task strategy designed address large problem size using fast simple heuristic present analytical experimental work demonstrating viability strategy issue direction presented future work toward goal efficient implementing unstructured multigrid algorithm current generation supercomputer
1994,randomized linear-time algorithm finding minimum spanning tree,present randomized linear-time algorithm finding minimum spanning tree connected graph edge weight algorithm modification one proposed karger us random sampling combination recently discovered linear-time algorithm verifying minimum spanning tree computational model unit-cost random-access machine restriction operation allowed edge weight binary comparison
1993,finding minimum-cost maximum flow series-parallel network,give fast algorithm computing minimum-cost maximum flow series-parallel network m-edge network algorithm run time space needed cost minimum-cost flow desired entire flow needed space bound reduced without increasing running time idea behind algorithm represent set augmenting path balanced search tree
1993,om log n-time algorithm maximal planar subgraph problem,based new version hopcroft tarjan planarity testing algorithm paper develops $o$-time algorithm find maximal planar subgraph
1993,confluently persistent deques via data structural bootstrapping,introduce data-structural bootstrapping technique design data structure recursively use design confluently persistent deques data structure requires worst-case time space per deletion k total number deque operation constant worst-case time space operation data structure allows purely functional implementation side effect improves previous result driscoll sleator tajan 
1992,maintaining bridge-connected biconnected component on-line,consider twin problem maintaining bridge-connected component biconnected component dynamic undirected graph allowed change graph vertex edge insertion give algorithm problem simple data structure algorithm run ino time wheren number vertex andm number operation develop modified version dynamic tree sleator tarjan suitable efficient recursive algorithm use reduce running time algorithm problem  functional inverse ackermanns function time bound optimal algorithm useo space
1992,linear-time algorithm finding ambitus,devise linear-time algorithm finding ambitus ín undirected graph ambitus cycle graph containing two distinguished vertex certain different group bridge  satisfy property bridge one group interlace bridge group thus ambitus allows graph cut piece piece certain graph property may investigated independently recursively piece pasted together yield information graph property original graph order achieve good time-complexity algorithm employing divide-and-conquer paradigm necessary find ambitus quickly also show using ambitus linear-time algorithm devised abiding-path-finding nonseparating-induced-cycle-finding problem
1992,polygon triangulation n log log n time simple data structure,give newo-time deterministic algorithm triangulating simplen-vertex polygon avoids use complicated data structure addition polygon whose vertex integer coordinate polynomially bounded size algorithm modified run ino time major new technique employed efficient location horizontal visibility edge partition interior polygon region approximately equal size linear-time algorithm obtaining horizontal visibility partition subchain polygonal chain horizontal visibility partition entire chain latter technique interesting application including linear-time algorithm convert steiner triangulation polygon true triangulation
1992,randomized parallel algorithm trapezoidal diagram,describe randomized parallel algorithm building trapezoidal diagram line segment plane algorithm designed crcw pram general segment give algorithm requiring optimal expected work optimal time number intersecting pair segment segment form simple chain give algorithm requiring optimal expected work expected time simpler algorithm requiring expected work serial algorithm corresponding latter among simplest known algorithm requiring expected operation set segment forming k chain give algorithm requiring expected work expected time parallel time bound require assumption enough processor available processor allocation every log n step
1992,maintenance minimum spanning forest dynamic plane graph,give efficient algorithm maintaining minimum spanning forest plane graph subject on-line modification modification supported include change edge weight insertion deletion edge vertex consistent given embedding implement algorithm develop data structure called edge-ordered dynamic tree variant dynamic tree data structure sleator tarjan using data structure algorithm run time per operation space algorithm used maintain connected component dynamic planar graph time per operation also show algorithm needamortized time per operation given set machine operation fairly general
1992,finding minimum-cost flow double scaling,several researcher recently developed new technique give fast algorithm minimum-cost flow problem paper combine several technique yield algorithm running log time network withn verticesm edge maximum arc capacityu maximum arc cost magnitudec major technique used capacity-scaling approach edmonds karp excess-scaling approach ahuja orlin cost-scaling approach goldberg tarjan dynamic tree data structure sleator tarjan nonsparse graph large maximum arc capacity obtain similar slightly better bound also obtain slightly better bound  transportation problem addition discus capacity-bounding approach minimum-cost flow problem
1992,verification sensitivity analysis minimum spanning tree linear time,komls devised way use linear number binary comparison test whether given spanning tree graph edge cost minimum spanning tree total computational work required method much larger linear however paper describes linear-time algorithm verifying minimum spanning tree algorithm combine result komls preprocessing table look-up method small subproblems previously known almost-linear-time algorithm additionally optimal deterministic algorithm linear-time randomized algorithm sensitivity analysis minimum spanning tree presented
1992,short encoding evolving structure,derivation transformational system graph grammar may redundant sense exact order transformation may affect final outcome matter transformation applied applied correct substructure taking advantage redundancy develop efficient encoding scheme derivation encoding scheme number diverse application used efficient enumeration combinatorial object compact representation program data structure transformation also used derive lower bound length derivation shown example $ $ application associative commutative law required worst case transform n-variable expression binary associative commutative operation equivalent expression similarly shown $ $ diagonal flip required worst case transform one n-vertex numbered triangulated planar graph one lower bound matching upper bound $o$ upper bound associative commutative operation known previously whereas $o$ upper bound diagonal flip obtained
1992,efficient bottom-up multi-pattern matching tree,pattern matching tree fundamental variety programming language system however progress slow satisfying pressing need general-purpose pattern-matching algorithm efficient time space offer asymptotic improvement time space chase bottom-up algorithm pattern preprocessing preliminary implementation algorithm run ten time faster chase  implementation hardest problem instance preprocessing algorithm advantage on-line respect pattern addition deletion also adapts favorable input instance hoffmann odonnells  class simple pattern performs better special-purpose algorithm tailored class show modify algorithm using new decomposition method obtain space/time tradeoff finally trade log factor time linear space bottom-up pattern-matching algorithm handle wide subclass hoffmann odonnells  simple pattern
1992,data structural bootstrapping linear path compression catenable heap ordered double ended queue,author provide efficient implementation catenable mindeques prove resulting data structure achieves constant amortized time per operation consider order preserving path compression prove linear bound deque ordered spine-only path compression case order persevering path compression employed data structure< >
1991,faster scaling algorithm general graph-matching problem,algorithm minimum-cost matching general graph integral edge cost presented algorithm run time close fastest known bound maximum-cardinality matching specifically let n n denote number vertex number edge largest magnitude cost respectively best known time bound maximum-cardinality matching new algorithm minimum-cost matching time bound  slight modification new algorithm find maximum-cardinality matching time application new algorithm given including efficient implementation christofides travelling salesman approximation algorithm efficient solution update problem require linear programming duals matching
1991,transitive compaction parallel via branching,study following problem given strongly connected digraph find minimal strongly connected spanning subgraph main result parallel algorithm problem run polylog parallel time us processor pram algorithm simple major tool us computing minimum-weight branching zero-one weight also present sequential algorithm problem run time
1991,efficiency primal network simplex algorithm minimum-cost circulation problem,study number pivot required primal network simplex algorithm solve minimum-cost circulation problem propose pivot selection rule bound n/+o number pivot n-vertex network first known subexponential bound network simplex algorithm rule implemented run n/+o time special case planar graph obtain polynomial bound number pivot running time also consider relaxation network simplex algorithm cost-increasing pivot allowed well cost-decreasing one algorithm propose pivot selection rule bound ofo log n}on number pivot network n vertex arc integer arc cost bounded magnitude c total running time iso log n}this bound within logarithmic factor best previously known algorithm minimum-cost circulation problem
1991,use dynamic tree network simplex algorithm maximum flow problem,goldfarb hao  proposed pivot rule primal network simplex algorithm solve maximum flow problem ann-vertexm-arc network mostnm pivot time paper describe extend dynamic tree data structure sleator tarjan  reduce running time algorithm bound le logarithmic factor larger fastest known algorithm problem extension dynamic tree interesting right may well additional application
1991,faster parametric shortest path minimum-balance algorithm,use fibonacci heap improve parametric shortest path algorithm karp orlin combine algorithm method schneider schneiders minimumbalance algorithm obtain faster minimumbalance algorithmfor graph n vertex edge parametric shortest path algorithm minimumbalance algorithm run time improved parametric shortest path algorithm karp orlin minimumbalance algorithm schneider schneideran important application parametric shortest path algorithm finding minimum mean cycle experiment random graph suggest expected time finding minimum mean cycle algorithm
1990,simplified linear-time jordan sorting polygon clipping,given intersection point jordan curve x-axis order occur along curve jordan sorting problem sort order occur along x-axis problem arises clipping simple polygon rectangle  efficient algorithm triangulating simple polygon hoffman mehlhorn rosenstiehl tarjan proposed algorithm solves jordan sorting problem time linear number intersection point algorithm requires use sophisticated data structure level-linked search tree propose variant algorithm hoffman et al retains linear-time bound simplifies primary data structure operation must perform
1990,faster algorithm shortest path problem,efficient implementation dijkstras shortest path algorithm investigated new data structure called radix heap proposed use algorithm network n vertex edge nonnegative integer arc cost bounded c one-level form radix heap give time bound dijkstras algorithm two-level form radix heap give bound combination radix heap previously known data structure called fibonacci heap give bound best previously known bound using fibonacci heap alone using priority queue structure van emde boa et al 
1990,finding minimum-cost circulation successive approximation,develop new approach solving minimum-cost circulation problem approach combine method solving maximum flow problem successive approximation technique based cost scaling measure accuracy solution amount complementary slackness condition violatedwe propose simple minimum-cost circulation algorithm one version run time n-vertex network integer arc cost absolute value c incorporating sophisticated data structure algorithm obtain time bound olog network arc slightly different use approach show minimum-cost circulation computed solving sequence blocking flow problem corollary result olog-time m-processor parallel minimum-cost circulation algorithm approach also yield strongly polynomial minimum-cost circulation algorithmsour  provide evidence minimum-cost circulation problem much harder maximum flow problem believe suitable implementation method perform extremely well practice
1990,efficient bottom-up tree pattern matching,pattern matching tree fundamental variety programming language system however progress slow satisfying pressing need general purpose pattern matching algorithm efficient time space offer asymptotic improvement time space chase bottom-up algorithm pattern preprocessing preprocessing algorithm additional advantage incremental respect pattern addition deletion show modify algorithm using new decomposition method obtain space/time tradeoff finally trade log factor time linear space bottom-up pattern matching algorithm handle wide subclass hoffmann odonnells simple pattern
1990,polygon triangulation log log n time simple data-structures,give new &ogr-time deterministic linear-time algorithm triangulating simple n-vertex polygon avoids use complicated data-structures addition polygon whose vertex integer coordinate polynomially bounded size algorithm modified run &ogr time major new technique employed efficient location horizontal visibility edge partition interior polygon region approximately equal size linear-time algorithm obtaining horizontal visibility partition subchain polygonal chain horizontal visibility partition entire chain latter technique interesting application including linear-time algorithm convert steiner triangulation polygon true triangulation research partially supported dimacs following grant nserc  nserc  nsf-stc- onr-n--
1990,maintenance minimum spanning forest dynamic planar graph,give efficient algorithm maintaining minimum spanning forest planar graph subject on-line modification modification supported include change edge weight insertion deletion edge vertex implement algorithm develop data structure called edge-ordered dynamic tree variant dynamic tree data structure sleator tarjan using data structure algorithm run time per operation space algorithm used maintain connected component dynamic planar graph time per operation
1990,unique binary search tree representation equality-testing set sequence,given ordered universe u study problem representing subset u unique binary search tree dictionary operation performed efficiently exhibit representation permit execution dictionary operation optimal time dictionary sufficiently sparse sufficiently dense apply unique representation obtain efficient data structure maintaining collection sets/sequences query test equality pair object process devise interesting method maintaining dynamic sparse array
1989,fast la vega algorithm triangulating simple polygon,present randomized algorithm triangulates simple polygon onn vertex ino expected time averaging analysis running time possible choice made algorithm bound hold input polygon
1989,tight amortized bound path reversal,path reversal form path compression used disjoint set union algorithm mutual exclusion algorithm derive tight upper bound amortized cost path reversal
1989,parallel algorithm finding blocking flow acyclic network,propose simple parallel algorithm finding blocking flow acyclic network n-vertex m-arc network algorithm run time space using m-processor erew pram consequence algorithm olog time space m-processor algorithm minimum-cost circulation problem network integer arc capacity magnitude c
1989,finding minimum-cost circulation canceling negative cycle,classical algorithm finding minimum-cost circulation consists repeatedly finding residual cycle negative cost canceling pushing enough flow around cycle saturate arc show judicious choice cycle canceling lead polynomial bound number iteration algorithm give simple strongly polynomial algorithm us scaling variant algorithm us dynamic tree run &ogrmin{log log n} time network n vertex arc arc cost maximum absolute value c bound comparable fastest previously known algorithm
1989,making data structure persistent,paper study persistence data structure ordinary data structure ephemeral sense change structure destroys old version leaving new version available use contrast persistent structure allows access version old new time develop simple systematic efficient technique making linked data structure persistent use technique devise persistent form binary search tree logarithmic access insertion deletion time space bound insertion deletion
1989,amortized analysis algorithm set union backtracking,mannila ukkonen  studied variant classical disjoint set union  problem extra operation called de-union undo recently performed union operation yet undone proposed way modify standard set union algorithm handle de-union operation paper several algorithm analyzed based approach efficient algorithm amortized running time $o$ per operation n total number element set algorithm use $o$ space space usage reduced $o$ simple change author prove separable pointer-based algorithm problem requires $ $ time per operation thus showing upper bound amortized time tight
1989,fast parametric maximum flow algorithm application,classical maximum flow problem sometimes occurs setting arc capacity fixed function single parameter goal find value parameter corresponding maximum flow minimum cut satisfies side condition finding desired parameter value requires solving sequence related maximum flow problem paper shown recent maximum flow algorithm goldberg tarjan extended solve important class parametric maximum flow problem cost constant factor worst-case time bound faster algorithm variety combinatorial optimization problem follow result
1989,improved time bound maximum flow problem,recently goldberg proposed new approach maximum network flow problem approach yield simple algorithm running $o$ time n-vertex network incorporation dynamic tree data structure sleator tarjan yield complicated algorithm running time $o$ m-arc network ahuja orlin developed variant goldberg algorithm us scaling run $o$ time network integer arc capacity bounded u paper possible improvement ahuja-orlin algorithm explored first improved running time $o$ obtained using nonconstant scaling factor second even better bound $o^{/} $ obtained combining ahuja-orlin algorithm wave algorithm tarjan third shown use dynamic tree latter algorithm reduces running time $o^{{ / }} + $ result show combined use three different technique  speed obtained using technique alone bound unit-cost random access machine also considered semilogarithmic computation model bound increase additive term $o$ time needed read input model
1989,faster scaling algorithm network problem,paper present algorithm assignment problem transportation problem minimum-cost flow problem operation research algorithm find minimum-cost solution yet run time close best-known bound corresponding problem without cost example assignment problem  solved $o$ time $nm$ n denote number vertex number edge largest magnitude cost cost assumed integral algorithm work scaling work goldberg tarjan scaled problem approximate optimum solution found rather exact optimum
1988,relaxed heap alternative fibonacci heap application parallel computation,relaxed heap priority queue data structure achieves amortized time bound fibonacci heap—a sequence decrease_key n delete_min operation take time variant relaxed heap achieves similar bound worst case—o time decrease_key delete_min relaxed heap give processor-efficient parallel implementation dijkstras shortest path algorithm hence algorithm network optimization relaxed heap type binomial queue allows heap order violated
1988,linear-time algorithm finding minimum spanning pseudoforest,pseudoforest graph whose connected component tree tree plus edge spanning pseudoforest graph contains greatest number edge possible paper show minimum cost spanning pseudoforest graph n vertex edge found time implies minimum spanning tree found time graph girth least logn constant
1988,new approach maximum-flow problem,previously known efficient maximum-flow algorithm work finding augmenting path either one path time  shortest-length augmenting path  alternative method based preflow concept karzanov introduced preflow like flow except total amount flowing vertex allowed exceed total amount flowing method maintains preflow original network push local flow excess toward sink along estimated shortest path algorithm analysis simple intuitive yet algorithm run fast known method dense graph achieving time bound n-vertex graph incorporating dynamic tree data structure sleator tarjan obtain version algorithm running time n-vertex m-edge graph fast known method graph density faster graph moderate density algorithm also admits efficient distributed parallel implementation parallel implementation running time using n processor space obtained time bound match shiloach-vishkin algorithm also us n processor requires space
1988,algorithm two bottleneck optimization problem,bottleneck optimization problem graph edge cost problem finding subgraph certain kind minimizes maximum edge cost subgraph bottleneck objective contrast common objective minimizing sum edge cost propose fast algorithm two bottleneck optimization problem problem finding bottleneck spanning tree directed graph n vertex edge propose analgorithm bottleneck maximum cardinality matching problem propose analgorithm
1988,one-processor scheduling symmetric earliness tardiness penalty,consider one-processor scheduling problem following form task  tn given ti specified length li preferred starting time ai  task scheduled nonpreemptively  single processor begin close preferred starting time possible examine two different cost measure schedule sum absolute discrepancy preferred starting time maximum discrepancy first show problem finding minimum cost schedule np-complete however give efficient algorithm find minimum cost schedule whenever task either length required executed given fixed sequence second cost measure give efficient algorithm find minimum cost schedule general constraint ordering length task
1988,log log n-time algorithm triangulating simple polygon,given simple n-vertex polygon triangulation problem partition interior polygon $n - $ triangle adding $n - $ nonintersecting diagonal propose $o$-time algorithm problem improving previously best bound $o$ showing triangulation hard sorting improved algorithm several computational geometry problem including testing whether polygon simple follow result
1988,almost-optimum speed-ups algorithm bipartite matching related problem,present algorithm matching related problem run erew pram p processor given bipartite graph g n vertex edge integral edge cost n magnitude give algorithm assignment problem  run &ogr/p time &ogr space p ≤ m/ p =  improves best known sequential algorithm within factor log  best known bound problem without cost  p >  time within factor log p optimum speed-up extension include algorithm maximum cardinality bipartite matching slightly better processor bound similar  bipartite degree-constrained subgraph problem  idea also extend general graph matching problem
1987,linear-time algorithm visibility shortest path problem inside triangulated simple polygon,given triangulation simple polygonp present linear-time algorithm solving collection problem concerning shortest path visibility withinp problem include calculation collection shortest path insidep given source vertex vertex ofp calculation subpolygon ofp consisting point visible given segment withinp preprocessingp fast ray shooting query several related problem
1987,algorithmic design,quest efficiency computational method yield fast algorithm also insight lead elegant simple general problem-solving method
1987,fibonacci heap us improved network optimization algorithm,paper develop new data structure implementing heap  structure fibonacci heap  extends binomial queue proposed vuillemin studied brown f-heaps support arbitrary deletion n-item heap amortized time standard heap operation amortized time using f-heaps able obtain improved running time several network optimization algorithm particular obtain following worst-case bound n number vertex number edge problem grapho single-source shortest path problem nonnegative edge length improved ono all-pairs shortest path problem improved ono assignment problem  improved ono minimum spanning tree problem improved β = min {i | logn ≤ m/n} note β ≤ log*n ≥ nof  improved bound minimum spanning tree striking although  give asymptotic improvement graph appropriate density
1987,three partition refinement algorithm,present improved partition refinement algorithm three problem lexicographic sorting relational coarsest partition double lexical ordering double lexical ordering algorithm us new efficient method unmerging two sorted set
1987,correction linear-time algorithm triangulating simple polygon,linear-time algorithm triangulating simple polygon  -  analysis showing author triangulation algorithm run linear time incorrect indeed algorithm run linear time worst case far unable obtain linear-time algorithm triangulation problem able obtain o-time algorithm however detail described o-time algorithm triangulating simple polygon siam journal computing    appear
1987,solving minimum-cost flow problem successive approximation,introduce framework solving minimum-cost flow problem approach measure quality solution amount complementary slackness condition violated show extend technique developed maximum flow problem improve quality solution framework allows u achieve &ogr log  running time
1986,pairing heap new form self-adjusting heap,recently fredman tarjan invented new especially efficient form heap  called thefibonacci heap although theoretically efficient fibonacci heap complicated implement fast practice kind heap paper describe new form heap called thepairing heap intended competitive fibonacci heap theory easy implement fast practice provide partial complexity analysis pairing heap complete analysis remains open problem
1986,locally adaptive data compression scheme,data compression scheme exploit locality reference occurs word used frequently short interval fall long period disuse described scheme based simple heuristic self-organizing sequential search variable-length encoding integer prove never performs much worse huffman coding perform substantially better experiment real file show performance usually quite close huffman coding scheme many implementation advantage simple allows fast encoding decoding requires one pas data compressed 
1986,planar point location using persistent search tree,classical problem computational geometry planar point location problem problem call preprocessing polygonal subdivision plane defined n line segment given sequence point polygon containing point determined quickly on-line several way solving problem query time space known rather complicated propose simple o-query-time o-space solution using persistent search tree persistent search tree differs ordinary search tree insertion deletion old version tree still accessed develop persistent form binary search tree support insertion deletion present query past time per query update total number update space needed per update planar point location algorithm immediate application data structure structure also provides alternative chazelles hive graph structure variety application geometric retrieval
1986,efficient algorithm finding minimum spanning tree undirected directed graph,recently fredman tarjan invented new especially efficient form heap  data structure thefibonacci heap  support arbitrary deletion ino amortized time heap operation ino amortized time paper use f-heaps obtain fast algorithm finding minimum spanning tree undirected directed graph undirected graph containingn vertex andm edge minimum spanning tree algorithm run ino time improved fromo time where=min {i|log n m/n} minimum spanning tree algorithm directed graph run ino time improved fromo n algorithm extended allow degree constraint one vertex
1986,rectilinear planar layout bipolar orientation planar graph,propose linear-time algorithm generating planar layout planar graph vertex represented horizontal line segment edge vertical line segment endpoint segment integer coordinate total space occupied layout mostn n– algorithm variant one otten van wijk generally produce compact layout allows dual graph laid interlocking way algorithm based concept abipolar orientation discus relationship among bipolar orientation planar graph
1986,sorting jordan sequence linear time using level-linked search tree,jordan curve c plane nowhere tangent x axis let x x… xn abscissa intersection point c x axis listed order point occur c call x x… xn jordan sequence paper describe o-time algorithm recognizing sorting jordan sequence problem sorting sequence arises computational geometry computational geography algorithm based reduction recognition sorting problem list-splitting problem solve list-splitting problem use level-linked search tree
1986,deques heap order,deque heap order deque  item real-valued key operation finding item minimum key allowed well usual deque operation combining standard deque implementation auxiliary heap  possible implement deque heap order worst-case time per operation n number item deque paper describes implementation deques heap order worst-case time per operation
1986,self-adjusting heap,paper explore two theme data structure design amortized computational complexity self adjustment motivated following observation application data structure wish perform single operation sequence operation possibly correlated behavior averaging running time per operation worst-case sequence operation sometimes obtain overall time bound much smaller worst-case time per operation multiplied number operation call kind averaging amortizationstandard kind data structure many variety balanced tree specifically designed worst-case time per operation small efficiency achieved imposing explicit structural constraint must maintained update cost running time storage space however amortized running time complexity measure interest guarantee efficiency without maintaining structural constraint instead access update operation adjust data structure simple uniform way call data structure self adjustingin paper develop skew heap self-adjusting form heap related leftist heap crane knuth  skew heap use le space leftist heap similar worst-case-efficient data structure competitive running time theory practice worst-case structure also easier implement derive information-theoretic lower bound showing skew heap minimum possible amortized running time within constant factor sequence certain heap operation
1986,linear time algorithm visibility shortest path problem inside simple polygon,present linear time algorithm solving following problem involving simple planar polygon p  computing collection shortest path inside p given source vertex vertex p  computing subpolygon p consisting point visible segment within p  preprocessing p query ray r emerging fixed edge e p find logarithmic time first intersection r boundary p  preprocessing p query point x p find logarithmic time portion edge e visible x  preprocessing p query point x inside p direction u find logarithmic time first point boundary p hit ray direction u x  calculating hierarchical decomposition p smaller polygon recursive polygon cutting   calculating  “convex ropes”  fixed vertex p lying convex hull vertex p algorithm based recent linear time algorithm tarjan van wyk triangulating simple polygon use additional technique make subsequent phase algorithm also linear
1986,rotation distance triangulation hyperbolic geometry,n/a
1986,new approach maximum flow problem,rotation binary tree local restructuring change tree another tree rotation useful design tree-based data structure rotation distance pair tree minimum number rotation needed convert one tree paper establish tight bound  maximum rotation distance two a-node tree large n using volumetric argument hyperbolic -space proof also give tight bound minimum number tetrahedron needed dissect polyhedron worst case reveals connection
1986,linear-time algorithm triangulating simple polygon,paper present linear-time algorithm special case disjoint set union problem structure union  known advance algorithm executes intermixed sequence union find operation n element ino time ando space slight theoretically significant improvement fastest known algorithm general problem run ino+n time ando space functional inverse ackermanns function used subroutine algorithm give similar improvement efficiency algorithm solving several problem including two-processor scheduling matching convex graph finding nearest common ancestor off-line testing flow graph reducibility finding two disjoint directed spanning tree algorithm obtains efficiency combining fast algorithm general problem table look-up small set requires random access machine implementation algorithm extends case single-node addition union tree allowed extended algorithm useful finding maximum cardinality matchings nonbipartite graph
1985,amortized efficiency list update paging rule,article study amortized efficiency “move-to-front” similar rule dynamically maintaining linear list assumption accessing ith element front list take &thgr time show move-to-front within constant factor optimum among wide class list maintenance rule natural heuristic transpose frequency count rule share property generalize  show move-to-front within constant factor optimum long access cost convex function also study paging setting access cost convex paging rule corresponding move-to-front “least recently used”  replacement rule analyze amortized complexity lru showing efficiency differs off-line paging rule  factor depends size fast memory on-line paging algorithm better amortized performance
1985,sequential access play tree take linear time,sleator tarjan invented form self-adjusting binary search tree called thesplay tree sufficiently long access sequence splay tree efficient within constant factor dynamically balanced static optimum search tree sleator tarjan made much stronger conjecture namely sufficiently long access sequence within constant factor splay tree efficient asany form dynamically updated search tree thisdynamic optimality conjecture implies special case accessing item splay tree sequential order take linear time ieo time per access paper prove special case conjecture generalizing unpublished result wegman oursequential access theorem support belief dynamic optimality conjecture provides additional insight working splay tree corollary result show splay tree used simulate output-restricted deques  linear time pose several open problem related result
1985,decomposition clique separator,consider problem decomposing graph mean clique separator mean finding clique  whose removal disconnect graph give o-time algorithm finding decomposition n-vertex m-edge graph describe decomposition used divide-and-conquer algorithm various graph problem graph coloring finding maximum independent set survey class graph divide-and-conquer algorithm especially useful
1985,self-adjusting binary search tree,splay tree self-adjusting form binary search tree developed analyzed binary search tree data structure representing table list accessing inserting deleting item easy n-node splay tree standard search tree operation amortized time bound per operation “amortized time” meant time per operation averaged worst-case sequence operation thus splay tree efficient balanced tree total running time measure interest addition sufficiently long access sequence splay tree efficient within constant factor static optimum search tree efficiency splay tree come explicit structural constraint balanced tree applying simple restructuring heuristic called splaying whenever tree accessed extension splaying give simplified form two data structure lexicographic multidimensional search tree link/cut tree
1985,linear-time algorithm special case disjoint set union,paper present linear-time algorithm special case disjoint set union problem structure union  known advance algorithm executes intermixed sequence union find operation n element time space slight theoretically significant improvement fastest known algorithm general problem run o+n time space functional inverse ackermanns function used subroutine algorithm give similar improvement efficiency algorithm solving several problem including two-processor scheduling matching convex graph finding nearest common ancestor off-line testing flow graph reducibility finding two disjoint directed spanning tree algorithm obtains efficiency combining fast algorithm general problem table look-up small set requires random access machine implementation algorithm extends case single-node addition union tree allowed extended algorithm useful finding maximum cardinality matchings nonbipartite graph
1985,note finding minimum-cost edge-disjoint spanning tree,let g undirected graph n vertex edge edge real-valued cost consider problem finding set k edge-disjoint spanning tree g minimum total edge cost problem solved polynomial time matroid greedy algorithm present implementation algorithm run time edge cost algorithm run time algorithm also extended find largest k k edge-disjoint spanning tree exist time mention several application algorithm
1985,strongly connected orientation mixed multigraphs,study problem orienting undirected edge mixed multigraph preserve reachability extending work robbins boesch tindell develop lineartime algorithm test whether orientation preserve strong connectivity construct orientation whenever possible algorithm make attempt minimize distance resulting directed graph indeed maximum distance example blow factor proportional number vertex graph extending work chvtal thomassen prove mixed multigraph radius r strongly connected orientation must orientation radius  + ar proof give polynomialtime algorithm constructing orientation
1985,biased search tree,consider problem storing item totally ordered set search tree access time given item depends known estimate access frequency item describe two related class biased search tree whose average access time within constant factor minimum easy update insertion deletion radical update operation present analyze efficient update algorithm biased search tree list several application tree
1985,efficient parallel biconnectivity algorithm,paper propose new algorithm finding block  undirected graph serial implementation run $o$ time space graph n vertex edge parallel implementation run $o$ time $o$ space using $o$ processor concurrent-read concurrent-write parallel ram alternative implementation run $o$ time $o$ space using number $p  n^ / ^ n$ processor concurrent-read exclusive-write parallel ram last algorithm optimal speedup assuming adjacency matrix representation input general algorithmic technique simplifies improves computation various function tree introduced technique typically requires $o$ time using processor $o$ space exclusive-read exclusive-write parallel ram
1985,linear time solution single function coarsest partition problem,problem finding coarsest partition set respect another partition one function several application one state minimization finite state automaton  hopcroft presented algorithm solve many function coarsest partition problem set n element time space  aho hopcroft ullman presented algorithm solves special case problem one function algorithm use negative strategy repeatedly refines original partition solution found present new algorithm solve single function coarsest partition problem time space using different constructive approach algorithm applied automated manufacturing woven fabric
1985,sorting jordan sequence linear time,jordan curve c plane let x_{}x_{}x_{n} abscissa intersection point c x-axis listed order point occur c call x_{}x_{}x_{n} jordan sequence paper describe o-time algorithm recognizing sorting jordan sequence problem sorting sequence arises computational geometry computational geography algorithm based reduction recognition sorting problem list-splitting problem solve list-splitting problem use level linked search tree
1984,worst-case analysis set union algorithm,paper analyzes asymptotic worst-case running time number variant well-known method path compression maintaining collection disjoint set union show two one-pass method proposed van leeuwen van der weide asymptotically optimal whereas several method including one proposed rem advocated dijkstra slower best method
1984,efficient algorithm family matroid intersection problem,consider matroid element real-valued cost color red green base sought contains q red element smallest possible cost algorithm problem general matroids presented along number variation efficiency demonstrated implementation specific matroids case one running time match best-known algorithm problem without red element constraint graphic matroids smallest spanning tree q red edge found time needed find minimum spanning tree special case finding smallest spanning tree degree constraint time needed find one minimum spanning tree transversal matching matroids time best-known algorithm minimum cost base also hold transversal matroids convex graph model scheduling problem unit-length job release time deadline partition matroids linear-time algorithm presented finally algorithm related general approach find smallest spanning tree directed graph given root degree constraint time match best-known algorithm problem without red element  constraint
1984,gauss code planar hamiltonian graph stack-sortable permutation,paper following three recognition problem considered  test whether given sequence gauss code planar self-intersecting curve  test whether given graph known hamiltonian cycle planar  test whether given permutation sorted using two stack parallel three problem closely related simple linear-time algorithm solves three described heart algorithm data structure previously used general planarity testing called pile twin stack
1984,separator theorem graph bounded genus,many divide-and-conquer algorithm graph based finding small set vertex edge whose removal divide graph roughly half graph necessary small separator useful class one class planar graph n-vertex graph drawn plane bisected removal vertex  – main result paper graph drawn surface genus g bisected removal vertex bound best possible within constant factor algorithm given finding separator take time linear number edge graph given embedding graph genus surface extension application  discussed
1984,quick method finding shortest pair disjoint path,let g directed graph containing n vertex one distinguished source edge nonnegative cost consider problem finding possible sink vertex v pair edgedisjoint path v minimum total edge cost suurballe given otime algorithm problem give implementation suurballes algorithm run time space algorithm build implicit representation n pair path given representation time necessary explicitly construct pair path given sink per edge path
1984,fast algorithm finding nearest common ancestor,consider following problem given collection rooted tree answer on-line query form nearest common ancester vertex x show pointer machine solves problem requires $ $ time per query worst case n total number vertex tree hand present algorithm random access machine uniform cost measure $ number bit per word requires $o$ time per query $o$ preprocessing time assuming collection tree static version problem tree change query obtain almost-linear-time  algorithm
1984,simple linear-time algorithm test chordality graph test acyclicity hypergraphs selectively reduce acyclic hypergraphs,chordal graph arise naturally study gaussian elimination sparse symmetric matrix acyclic hypergraphs arise study relational data base rose tarjan lueker  pp  given linear-time algorithm test whether graph chordal yannakakis modified test whether hypergraph acyclic develop simplified linear-time test graph chordality hypergraph acyclicity test us new kind graph  search call maximum cardinality search variant method give way selectively reduce acyclic hypergraphs needed evaluating query acyclic relational data base
1984,finding biconnected component computing tree function logarithmic parallel time extended summary,propose new algorithm finding block  undirected graph serial implementation run  time space graph n vertex edge parallel implmentation run  time  space using  processor concurrent-read concurrent-write parallel ram alternative implementation run  time  space using number p ⩽ n/sup /log/sup /-n processor concurrent-read exclusive-write parallel ram latter algorithm optimal speedup assuming adjacency matrix representation input general algorithmic technique simplifies improve computation various function tress introduced technique typically requires  time using  space exclusive-read exclusive-write parallel ram
1984,linear time algorithm solve single function coarsest partition problem,problem finding coarsest partition set respect another partition one function several application one state minimization finite state automaton  hopcroft presented algorithm solve many function coarsest partition problem set n element time space aho hopcroft ullman later presented algorithm solves special case problem one function algorithm use negative strategy repeatedly refines original partition solution found present new algorithm solve single function coarsest partition problem time space using different constructive approach
1984,scaling related technique geometry problem,three technique computational geometry explored scaling solves problem viewing increasing level numerical precision activation restricted type update operation useful sweep algorithm cartesian tree data structure problem involving maximum minimum technique solve minimum spanning tree problem rk rk@@@@ orlg lg n time space rk@@@@ k ≥  r = k- rk r =    k =    r = k k >  problem solved include rkand rk nearest neighbor post office maximum spanning tree rk maximum rk rectangle searching problem zkp nearest neighbor 
1984,amortized efficiency list update rule,paper study amortized complexity two well-known algorithm used system software move-to-front rule maintaining unsorted linear list representing set least-recently-used replacement rule reducing page fault two-level paged memory algorithm subjected much analysis average case studying amortized complexity algorithm able gain additional insight behavior
1983,updating balanced search tree o1 rotation,olivié recently introduced class ‘half-balanced’ binary search tree access time require constant number single rotation rebalancing insertion deletion paper show well-known class balanced binary tree ‘symmetric binary b-trees’ bayer property surprising bayer class oliviés class contain exactly binary tree
1983,improved algorithm hierarchical clustering using strong component, author presented time algorithm hierarchically decomposing directed n-vertex m-edge graph weighted edge strong component algorithm useful cluster analysis data asymmetric similarity measure present paper give simpler algorithm faster running time
1983,data structure dynamic tree,data structure proposed maintain collection vertex-disjoint tree sequence two kind operation link operation combine two tree one adding edge cut operation divide one tree two deleting edge operation requires time using data structure new fast algorithm obtained following problem computing nearest common ancestor solving various network flow problem including finding maximum flow blocking flow acyclic flow computing certain kind constrained minimum spanning tree implementing network simplex algorithm minimum-cost flowsthe significant application  o-time algorithm obtained find maximum flow network n vertex edge beating factor log n fastest algorithm previously known sparse graph
1983,space-efficient implementation graph search method,several space-efficient implementation two common useful kind graph search namely breadth-first search depth-first search discussed straightforward implementation method requires n bit n + pointer auxiliary storage n number vertex graph devise method need n + bit read-only number edge graph save space folding queue stack required search graph representation two method depth-first search variant deutsch-schorr-waite list marking algorithm algorithm expressed version dijkstras guarded command language
1983,self-adjusting binary tree,use idea self-adjusting tree create new simple data structure priority queue  search tree unlike efficient implementation data structure self-adjusting tree balance condition instead whenever tree accessed certain adjustment take place  self-adjusting tree efficient amortized sense particular operation may slow sequence operation must fast self-adjusting tree two advantage corresponding balanced tree application first simpler implement fewer case algorithm second storage-efficient balance information need stored furthermore self-adjusting search tree remarkable property running time  within constant factor running time set search fixed binary tree follows self-adjusting tree  fast optimal fixed tree particular probability distribution search request even though distribution unknown
1982,hierarchical clustering algorithm using strong component,n/a
1982,sensitivity analysis minimum spanning tree shortest path tree,n/a
1982,asymptotically tight bound time-space trade-off pebble game,n/a
1982,symbolic program analysis almost-linear time,paper describes algorithm construct expression given program text symbolic expression whose value equal value text expression execution program call mapping text expression symbolic expression cover cover useful program optimization technique constant propagation code motion particular cover constructed method general weaker cover obtainable method     method advantage efficient requires $o + l$ operation extended bit vector operation unit cost n number vertex control flow graph program number edge l length program text $ $ related functional inverse ackermanns function  method require program well-structured flow graph reducible
1982,recognition series parallel digraph,present linear-time algorithm recognize class vertex series-parallel  digraph method based relationship vsp digraph class edge series-parallel multidigraphs byproduct analysis obtain efficient method compute transitive closure transitive reduction vsp digraph test isomorphism minimal vsp digraph
1981,unified approach path problem,describe general method solving path problem directed graph path problem include finding shortest path solving sparse system linear equation carrying global flow analysis computer program method consists two step first construct collection regular expression representing set path graph done using standard algorithm gaussian gauss-jordan elimination next apply natural mapping regular expression given problem domain exhibit mapping required find shortest path solve sparse system linear equation carry global flow analysis  provide general-purpose algorithm solving path problem show problem constructing path expression sense general path problem
1981,fast algorithm solving path problem,let g =  directed graph distinguished source vertex single-source path expression problem find vertex v regular expression p represents set path g v solution problem used solve shortest path problem solve sparse system linear equation carry global flow analysis describe method compute path expression dividing g component computing path expression component gaussian elimination combining solution method requires time reducible flow graph n number vertex g number edge g $$ functional inverse ackermanns function method make use algorithm evaluating function defined path tree simplified version algorithm run time reducible flow graph quite easy implement efficient practice
1981,scheduling unit-time task arbitrary release time deadline,basic problem considered scheduling n unit-time task arbitrary release time deadline minimize maximum task completion time previous work shown problem solved rather easily release time integer concerned general case noninteger release time allowed generalization considerably increase difficulty problem even single processor  one-processor case provide $o$ algorithm based concept forbidden region
1981,greedy heuristic complete matching,finding minimum weighted complete matching set vertex distance satisfy triangle inequality general interest particular importance drawing graph mechanical plotter greedy heuristic repeatedly matching two closest unmatched point implemented worst-case time $o$ reasonable saving compared general minimum weighted matching algorithm requires time proportional $n^ $ find minimum cost matching weighted graph show even number n vertex whose distance satisfy triangle inequality ratio cost matching produced greedy heuristic cost minimal matching ${}_^ n^{ _^ } - $ $ _^  $ example achieve bound conclude greedy heuristic although desirable simplicity would poor choice problem
1980,space complexity pebble game tree,n/a
1980,variation common subexpression problem,let g directed graph vertex v g successor v ordered let c equivalence relation vertex g congruence closure c* c finest equivalence relation containing c two vertex corresponding successor equivalent c* equivalent c* efficient algorithm described computing congruence closure general case following two special case  g c* acyclic  g acychc c identifies single pair vertex use algorithm test expression eqmvalence  test losslessness join relational database described
1980,linear expected-time algorithm connectivity problem,paper describes fast average-time algorithm four graph connectivity problem algorithm run average time n-vertex graph developed finding connected component strong component block o-time algorithm find minimum spanning forest m-graph also presented analysis algorithm us random graph model erdös renyi algorithm optimum within constant factor
1980,pebbling problem complete polynomial space,paper study pebbling problem model storage requirement various kind computation sethi shown problem $np$-hard lingas shown generalization p-space complete prove original problem p-space complete using modification lingass proof pebbling problem example p-space complete problem exhibiting obvious quantifier alternation
1980,design analysis data structure representing sorted list,paper explore use - tree represent sorted list analyze worst-case cost sequence insertion deletion - tree following three assumption  insertion performed  deletion performed  deletion occur small end list insertion occur away small end analysis lead data structure representing sorted list access pattern exhibit  locality reference structure many property representation proposed guibas mccreight plass robert  substantially simpler may practical list moderate size
1980,application planar separator theorem,n-vertex planar graph property divided component roughly equal size removing $o$ vertex separator theorem combination divide-and-conquer strategy lead many new complexity  planar graph problem paper describes 
1980,performance bound level-oriented two-dimensional packing algorithm,analyze several level-oriented algorithm packing rectangle unit-width infinite-height bin minimize total height packing three algorithm discus show ratio height obtained algorithm optimal height asymptotically bounded respectively    latter two improve substantially performance bound previously proposed algorithm addition give refined bound special case width given rectangle restricted square packed
1980,biased 2-3 tree,describe new data structure maintaining collection weighted item access time item weight w collection total weight w proportional log worst case  several useful operation made work fast data structure simpler previous proposal running time must amortized sequence operation achieve time bound
1980,prime subprogram parsing program,parsing method based triconnected decomposition biconnected graph presented parsing algorithm run linear time handle large class flow graph application algorithm flow analysis automatic structuring program discussed
1980,linear expected-time algorithm connectivity problem extended abstract,researcher recent year developed many graph algorithm fast worst case little work done graph algorithm fast average  karp  schnorr  paper analyze expected running time four algorithm solving graph connectivity problem goal exhibit algorithm whose expected time within constant factor optimum shed light property random graph section  develop analyze simple algorithm find connected component undirected graph n vertex expected time section   describe algorithm finding strong component directed graph block undirected graph expected time time required three problem ω worst case number edge graph since edge must examined  show edge must examined average*@@@@ section  present algorithm finding minimum weight spanning forest undirected graph edge weight expected time
1979,storing sparse table,problem storing searching large sparse table ubiquitous computer science standard technique storing table hashing hashing poor worst-case performance propose good worst-case method storing static table n entry integer  n -  method requires word storage allows access time although method little complicated use practice analysis show simpler algorithm used compressing lr parsing table work well
1979,linear-time algorithm testing truth certain quantified boolean formula,n/a
1979,fast merging algorithm,algorithm merges sorted list represented height-balanced binary tree given list length n merging procedure run step order lower bound comparison-based algorithm problem
1979,application path compression balanced tree,devise method computing function defined path tree method based tree manipulation technique first used efficiently representing equivalence relation almost-linear running time apply method give algorithm two problem verifying minimum spanning tree undirected graph   b finding dominators directed graph   n number vertex number edge problem graph $$ slowly growing function related functional inverse ackermanns function method also useful solving time certain kind pathfinding problem reducible graph problem occur global flow analysis computer program context companion paper discus application
1979,class algorithm require nonlinear time maintain disjoint set,paper describes machine model intended useful deriving realistic complexity bound task requiring list processing example use model paper defines class algorithm compute union disjoint set on-line prof algorithm requires nonlinear time worst case set union algorithm known author instance model thus subject derived bound one known algorithm achieves bound within constant factor
1979,fast algorithm finding dominators flowgraph,fast algorithm finding dominators flowgraph presented algorithm us depth-first search efficient method computing function defined path tree simple implementation algorithm run time number edge n number vertex problem graph sophisticated implementation run time &agr functional inverse ackermanns function version algorithm implemented algol w stanford university version algol tested ibm / program compared implementation purdom moore straightforward o-time algorithm bit vector algorithm described aho ullman fast algorithm beat straightforward algorithm bit vector algorithm smallest graph tested
1979,efficient algorithm simple matroid intersection problem,given matroid element realvalued cost colored red green seek minimum cost base exactly q red element simple case matroid intersection problem general algorithm presented efficiency illustrated special case finding minimum spanning tree q red edge time log n efficient algorithm also given job scheduling matroids partition matroids algorithm given finding minimum spanning tree vertex r prespecified degree show problem equivalent finding minimum spanning tree without degree constraint algorithm given finding minimum spanning tree directed graph given root r prespecified degree time problem without degree constraint
1979,upper lower bound time-space tradeoff,paper derives asymptotically tight bound time-space tradeoff pebbling three different class directed acyclic graph let n size graph number available pebble time necessary pebbling graph  time space tradeoff form st &equil &thgr proved special class permutation graph implement bit reversal permutation  time-space tradeoff form &equil &thgr&thgr proved class graph constructed stacking superconcentrators series  time-space tradeoff form &equil s&thgris proved pebbling general directed acyclic graph
1978,time-space trade-off pebble game,summarya certain pebble game graph studied various context model time space requirement computation  note shown exists family directed acyclic graph gn constant c c c thatgn n node node gn indegree  graph gn pebbled c√n pebble n move graph gn also pebbled c√n pebble c<c every strategy achieves least  c √n move 
1978,triangulating simple polygon,n/a
1978,linear-time algorithm finding feedback vertex,n/a
1978,representation linear list movable finger,paper describes data structure useful representing linear list pattern access list exhibit  locality reference structure many property representation proposed guibas mccreight plass robert  substantially simpler may practical list moderate size analysis structure includes general treatment worst-case node splitting caused consecutive insertion - tree
1977,space bound game graph,study one-person game played placing pebble according certain rule vertex directed graph  shown graph withn vertex maximum in-degreed pebbling strategy requires mostc n/logn pebble show bound tight within constant factor also analyze variety pebbling algorithm including one achieves  bound
1977,finding optimum branching,chu liu edmonds bock independently devised efficient algorithm find optimum branching directed graph give implementation algorithm run  time problem graph n vertex edge modification dense graph give running time  also show unmodified algorithm run  +m time average graph assuming uniform probability distribution
1977,finding maximum independent set,present algorithm find maximum independent set n-vertex graph $o$ time algorithm thus handle graph roughly three time large could analyzed using naive algorithm
1977,application planar separator theorem,n-vertex planar graph property divided component roughly equal size removing vertex separator theorem combination divide-and-conquer strategy lead many new complexity  planar graph problem paper describes 
1977,reference machine require non-linear time maintain disjoint set,paper describes machine model intended useful deriving realistic complexity bound task requiring list processing example use model paper show machine requires non-linear time worst case compute union disjoint set on-line set union algorithm known author instance model thus subject derived bound one known algorithm achieves bound within constant factor
1976,edge-disjoint spanning tree depth-first search,paper present algorithm finding two edge-disjoint spanning tree rooted fixed vertex directed graph algorithm us depthfirst search efficient method computing disjoint set union requires  time space analyze graph n vertex e edge   slowly growing function related functional inverse ackermanns function
1976,lower bound length node sequence directed graph,strong node sequence directed graph g= sequence node containing every cycle-free path g subsequence weak node sequence g sequence node containing every basic path g subsequence basic path n n … nk path n nk proper subsequence path n nk  kennedy developed global program data flow analysis method using node sequence kwiatowski kleitman shown strong node sequence complete graph n node must length least n−o arbitrary positive ε every graph n node strong sequence length n–n+ bound tight within however complete graph n node weak node sequence length n node  weak node sequence g length least / log n−o aho ullman shown every reducible flow graph strong node sequence length thus bound tight within constant factor reducible graph also show infinitely many n  flow graph h n node  weak node sequence h length least cn c positive constant bound tight within constant factor
1976,combinatorial problem complete polynomial space,paper considers generalization called shannon switching game vertex familiar board game called hex shown determining win game player play perfectly hard fact game problem solvable polynomial time problem solvable polynomial space solvable polynomial time result suggests theory combinational game difficult
1976,intersection graph curve plane,let v set curve plane corresponding intersection graph v set vertex two vertex connected edge two corresponding curve intersect planeit shown set intersection graph curve plane proper subset set undirected graph furthermore set intersection graph straight line-segments proper subset set intersection graph curve plane finally shown every k ≥  problem determining whether intersection graph straight line-segments k-colorable np-complete
1976,b-matchings tree,develop linear-time algorithm find maximum weighted unweighted degree-constrained subgraphs  tree use generalization algorithm finding maximum -matching tree
1976,algorithmic aspect vertex elimination graph,consider graph-theoretic elimination process related performing gaussian elimination sparse symmetric positive definite system linear equation give new linear-time algorithm calculate fill-in produced elimination ordering give two new related algorithm finding ordering special property one algorithm based breadth-first search find perfect elimination ordering exists $o$ time problem graph n vertex e edge extension algorithm find minimal  ordering $o$ time conjecture problem finding minimum ordering np-complete
1976,augmentation problem,paper considers problem object add minimum-weight set edge graph satisfy given connectivity condition simple characterization minimum number edge necessary make directed graph strongly connected make undirected graph bridge-connected biconnected given efficient algorithm finding minimum set edge discussed shown weighted version problem np-complete
1976,planar hamiltonian circuit problem np-complete,consider problem determining whether planar cubic triply-connected graph g hamiltonian circuit show problem np-complete hence hamiltonian circuit problem class graph larger class containing graph probably computationally intractable
1976,finding minimum spanning tree,paper study method finding minimum spanning tree graph  include  several algorithm $o$ worst-case running time n number vertex number edge problem graph  $o$ worst-case algorithm dense graph $ positive constant $ $  $o$ worst-case algorithm planar graph  relationship problem might lead general lower bound complexity minimum spanning tree problem
1976,computing  st  -numbering,lempel even cederbaum proved following result given edge {st} biconnected graph g n vertex vertex g numbered  n vertex receives number  vertex receives number n vertex except adjacent lower-numbered higher-numbered vertex  used result efficient algorithm planarity-testing provide linear-time algorithm computing st-numbering biconnected graph algorithm combined new  booth lueker provide linear-time implementation lempel-even-cederbaum planarity-testing algorithm
1976,space bound game graph,study one-person game played placing pebble according certain rule vertex directed graph  shown graph n vertex maximum in-degree  pebbling strategy requires c n/log n pebble show bound tight within constant factor also analyze variety pebbling algorithm including one achieves  bound
1975,optimal chain partition tree,n/a
1975,efficiency good linear set union algorithm,two type instruction manipulating family disjoint set partition universe n element considered find computes name unique set containing element x union combine set b new set named c known algorithm implementing sequence instruction examined shown maximum time required sequence find n -  intermixed union positive constant related functional inverse ackermanns function slow growing
1975,network flow testing graph connectivity,algorithm dinic finding maximum flow network described shown vertex capacity equal one algorithm requires $o$ time edge capacity equal one algorithm requires $o$ time also bound tight dinics algorithmthese  used test vertex connectivity graph $o$ time edge connectivity $o$ time
1975,algorithmic aspect vertex elimination,consider graph-theoretic elimination process related performing gaussian elimination sparse symmetric unsymmetric system linear equation discus good algorithm finding elimination ordering showing generalization breadth-first search called lexicographic search used find perfect ordering  time minimal ordering  time problem graph undirected n vertex e edge also give efficient  algorithm generating ordering directed graph claim minimum ordering problem directed graph np-complete conjecture also np-complete undirected graph include brief discussion relation elimination transitive closure discus unresolved general issue
1974,note finding bridge graph,n/a
1974,new algorithm finding weak component,n/a
1974,good algorithm edge-disjoint branching,n/a
1974,efficient planarity testing,paper describes efficient algorithm determine whether arbitrary graph g embedded plane algorithm may viewed iterative version method originally proposed auslander parter correctly formulated goldstein algorithm used depth-first search time space bound v number vertex g algol implementation algorithm succesfully tested graph many  vertex le  second
1974,testing flow graph reducibility,many problem program optimization solved applying technique called interval analysis flow graph program flow graph susceptible type analysis called reducible paper describes algorithm testing whether flow graph reducible algorithm us depth-first search reveal structure flow graph good method computing disjoint set union determine reducibility search information algorithm implemented random access computer requires time analyze graph e edge log*x=min{i‖logx≤} time bound compare favorably bound previously known algorithm
1974,finding dominators directed graph,paper describes algorithm finding dominators arbitrary directed graph algorithm us depth-first search efficient algorithm computing disjoint set union manipulating priority queue achieve time bound $o$ v number vertex e number edge graph bound compare favorably $o$ time bound previously known algorithm finding dominators arbitrary directed graph $o$ time bound known algorithm finding dominators reducible graph $e  v v$ new algorithm requires $o$ time optimal within constant factor
1974,testing graph connectivity,algorithm proposed dinic finding maximum flow network hopcroft karp finding maximum bipartite matchings applied graph connectivity problem shown algorithm requires  time find maximum set node-disjoint path graph  time find maximum set edge disjoint path bound tight thus node connectivity graph may tested  time edge connectivity graph may tested  time
1973,efficient algorithm graph manipulation h algorithm 447,efficient algorithm presented partitioning graph connected component biconnected component simple path algorithm partitioning graph simple path iterative iteration produce new path two vertex already path  v number vertex e number edge algorithm requires time space proportional max  executed random access computer
1973,v log v algorithm isomorphism triconnected planar graph,algorithm determining whether two triconnected planar graph isomorphic presented asymptotic growth rate algorithm bounded constant time |v| log |v| |v| number vertex graph
1973,time bound selection,number comparison required select i-th smallest n number shown linear function n analysis new selection algorithm—pick specifically  n comparison ever required bound improved extreme value new lower bound requisite number comparison also proved
1973,dividing graph triconnected component,algorithm dividing graph triconnected component presented implemented random access computer algorithm requires $o$ time space analyze graph v vertex e edge algorithm theoretically optimal within constant factor efficient practice
1973,enumeration elementary circuit directed graph,algorithm enumerate elementary circuit directed graph presented algorithm based backtracking procedure tiernan us lookahead labeling technique avoid unnecessary work time bound $o$ applied graph v vertex e edge c elementary circuit
1972,determining whether groupoid group,n/a
1972,sorting using network queue stack
1972,depth-first search linear graph algorithm,value depth-first search backtracking technique solving problem illustrated two example improved version algorithm finding strongly connected component directed graph algorithm finding biconnected component undirect graph presented space time requirement algorithm bounded $k_ v + k_ e + k_ $ constant $k_ k_ $ $k_ $ v number vertex e number edge graph examined
1972,isomorphism planar graph,algorithm presented determining whether two planar graph isomorphic algorithm requires time v number vertex graph
1972,linear time bound median computation,new upper lower bound presented maximum number comparison f required select i-th largest n number upper bound found analysis new selection algorithm linear function n f ≤ n/ < n  ≤ ≤ n lower bound shown deductively f ≥ n+min +  −   ≤ ≤ n− case computing median fn ≥ n/ − 
1971,v² algorithm determining isomorphism planar graph,n/a
1971,depth-first search linear graph algorithm working paper,value depth-first search backtracking technique solving graph problem illustrated two example algorithm finding biconnected component undirected graph improved version algorithm finding strongly connected component directed graph presented space time requirement algorithm bounded kv + ke + k constant k k k v number vertex e number edge graph examined
1971,planarity testing v log v step extended abstract,n/a
