1989,organithms dynamic software evolution,summary form given follows software system static useful one evolves rapidly greater number user rapid change one design change one treat specification dynamically issue must treated local global prototyping rapid reconfiguring control function access diffusion property implementation language crucial lisp-based implementation language preferable ada machine architecture play important part one separate portability evolution
1986,fac functional apl language,fac functional array calculator language feature apl syntax array operation allows partition operator infinite arrays–extensions semantically wthat semantically implausible apl
1985,another view software panel,ass role value ai tool logic domain software must sure appreciate nature domain unfortunately great deal truth statement “software computer life planet” thus know many kind software created many kind way serving myriad purpose appreciate key issue life examining human completely satisfactory way examining tool tool understand software must go beyond technique methodology carefully painfully crafted eg high level language structured programming data structure type semaphore functional programming etc adding tool change thing much probably tell u much software way dissatisfaction software surfaced operating system offspring think created provide open set service pool loosely cooperating function furthermore set service pool function would tolerate bound number intricacy communication efficiency computer use believe word “software” obscures issue dominate concern choose word “organithm” identify class program study software engineering operating system archetype organithms paraphrasing bernal organithm partial continuous progressive multiform conditionally interactive realization potentiality human thought expressed computer program thought organithm large collection perhaps limiting program held together useful traffic pattern may say part perfect purpose collection never adequate thus always state evolution supporting evolution major goal software engineering put another way dynamic organithm development set locus concern software engineering organithms model mental abstraction model approximation never enough state serve “uniform” approximants mental abstraction thrive deduction induction increase set accessible state sooner later like interpolants turn sour must change often unanticipated way order remain use organithms model organithms maintained reared like living matter continual consumer energy continual producer waste creation organithm implies support act husbandry thus research process organithm husbandry vital concern software engineering since organithms compete biosphere—the computer—improvement performance eternally sought result organithms state concerned management internals organithm develops ever increasing concern logic internal management significantly smaller fraction logic devoted serving external utility organithms tend take advantage purpose develop internal function organithm tend maximize use external function organithm exists supply-this called closing loop often internal us intensify traffic degree organithms created manage use external function eg mail system must capable supporting organithms generate read mail every external purpose organithm replaced organithmic surrogate since organithms model take little modification model unanticipated abstraction course development organithms suggest abstraction valuable support organithms fuel expansion abstract modeling technological activity unlike life reproduction dominates mutation organithms simple mutation still dominates reproduction change major role ai logic help creation organithms increasingly extricate u direct involvement internal growth organithms major issue software engineering environment ease task programming system accelerate rate improvement internal function obtained without unduly jeopardizing external function organithm maximizing use organithms perform reorganization insofar ai logic support autonomy activity development response value software enterprise
1982,syntax-free semantics apl operator,n/a
1982,epigram programming,n/a
1979,social process proof theorem program,argued formal verification program matter obtained play key role development computer science software engineering proof mathematics furthermore absence continuity inevitability change complexity specification significantly many real program make formal verification process difficult justify manage felt ease formal verification dominate program language design
1969,identifying developing curriculum software engineering,one basis developing education program recognition continuing need certain class professional society
1967,proposal definition algol,one important problem computer development today difficult job constructing program programming language handle wide variety task two pure approach programming language design endless number mixed approach lying one pure approach often taken graduate student university create new programming language problem approach perhaps typified certain supporter pl/i design language intended hopefully thing programmer unfortunately neither pure approach really practical people long recognized common feature programming problem agree certain technique applicable almost however burgeoning use machine possible assert degree confidence discovered useful technique reasonable way proceed seems design programming language contains common feature people discovered various problem allows user extend mold language suit particular application
1967,synthesis algorithmic system,n/a
1966,new policy algorithm,debate way concerning algorithm section communication specifically considerable sentiment favor also publishing algorithm language algol
1964,format language,one primitive part formula language specification input-output action within framework language specification intrinsically complex say evaluation arithmetic expression difficulty associated input-output specification arise fact desired operation properly defined using framework programming language indeed complexity largely disappears programming language constructed specify input-output action point made definition appropriate programming language make rational simpler three phase input-output programming cycle  source program construction  object program construction  object program execution
1964,extension algol manipulating formula,n/a
1964,programming digital computer,n/a
1964,acm publish computer research,n/a
1963,revised report algorithm language algol 60,n/a
1963,computation development critical society,acms growth continues  member expense also grow professional membership spring uniformly trained group mathematics physic even economics instead increasing membership come might call intellectual adventures—pioneers over-organized society—who see great future computing level aspiration
1963,revised report algorithmic language algol 60,n/a
1962,compiling matrix operation,unfortunate almost presently used algebraic language provide capability linear algebra operation inner product vector product two matrix multiplication matrix scaler must inevitably written detail term individual component reason usually given avoiding linear algebra language  difficulty would arise scanning linear algebraic expression  uncertainty involved amount temporary storage needed evaluation linear algebraic expression program executed purpose paper show two type difficulty overcome although suggestion made even increasing general capability algol including ability form matrix collection vector shall content consider ordinary operation linear algebra even much becomes available algebraic language considerable progress made following remark constitute suggestion addition algol linear algebraic expression
1961,use threaded list constructing combined algol machine-like assembly processor,n/a
1960,symbol manipulation threaded list,n/a
1960,report algorithmic language algol 60,n/a
1959,visit computation center soviet union,n/a
1959,algol sub-committee report - extension,n/a
1959,acm publication policy plan,n/a
1959,report algorithmic language algol acm committee programming language gamm committee programming,n/a
1959,symposium automatic programming,n/a
1958,preliminary report-international algebraic language,n/a
