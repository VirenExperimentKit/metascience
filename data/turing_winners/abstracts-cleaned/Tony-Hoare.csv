2019,logic algebra geometry foundation computer science,paper show example theory programming taught first-year c undergraduate prerequisite high school acquaintance algebra geometry propositional calculus main purpose teaching subject support practical programming assignment project throughout degree course aim would increase student’s enjoyment programming reduce workload increase prospect success
2019,calculus space time causality algebra geometry logic,calculus formalises human intuition common sense space time causality natural world intention assist design implementation program programming language interworking tool chain support rational program developmentthe thesis paper concurrent kleene algebra  algebra programming diagram unified modeling language provide geometry unifying theory programming  provides logic thesis illustrated formalisation feature first concurrent object-oriented language simula  level calculus conservative extension predecessorwe conclude paper extended section future research direction developing applying utp cka calculus propose implement algebra geometry logic
2016,development concurrent kleene algebra,highlights•we define informally interpret operator concurrent kleene algebra •programs set trace consist occurrence primitive actions•refinement ordering trace inequational law lift programs•several model cka refinement related concurrent programming practice•we detail several direction extend presented researchabstractthis report summarises  recent progress research co-authors aimed construction link algebraic presentation principle programming exploitation concurrency modern programming practice signature law concurrent kleene algebra  largely overlap regular algebra addition concurrent composition simple law re-interpreted application computer program inclusion relation regular expression re-interpreted refinement ordering support stepwise contractual approach software system design program debuggingthe law supported hierarchy model applicable adaptable range different purpose range different programming language algebra presented three tier bottom tier defines trace program execution represented set event occurred particular run program middle tier defines program set trace possible behaviour top tier introduces additional incomputable operator useful describing desired undesired property computer program behaviour final section outline direction research needed
2016,discrete geometric model concurrent program execution,trace execution concurrent object-oriented program displayed two-dimensions diagram non-metric finite geometry action program represented point object thread vertical line transaction horizontal line communication resource sharing sloping arrow partial trace rectangular figureswe prove informally geometry satisfies law concurrent kleene algebra  describe justify interleaved implementation multithreaded program computer system lesser number concurrent processor familiar form semantics  derived ckaprograms represented set possible trace execution non-determinism introduced union set geometry extended multiple level abstraction granularity method call higher level modelled specification method body implemented lower levelthe final section describes axiom definition geometry encoded interactive proof tool isabelle report progress towards automatic checking proof paper
2015,exploring interface model cka,concurrent kleene algebra  serve describe general concurrent system unified way abstract algebraic level recently graph-based model cka defined incoming outgoing edge graph define input/output interface present paper provides simplification significant extension original model cover notion state predicate assertion vein algebraic treatment using modal semirings moreover us extension set variant temporal logicctl∗for interface model
2014,law programming unify process calculus,survey well-known algebraic law sequential programming propose le familiar law concurrent programming basis law derive rule number classical programming process calculus example due hoare milner kahn algebraic law simpler calculus derived stronger calculus put together conversely law derivable one calculus suggests law useful presentation program semantics correspond widely held common understanding meaning program evidence appendix describes realistic generic model program behaviour proved satisfy law
2014,law programming algebraic unification theory concurrency,began academic research career  moved industrial employment programmer chair computing queen’s university belfast chosen research goal discover axiomatic basis computer programming originally wanted express axiom algebraic equation like provide basis arithmetic group theory know many intellectual vicissitude discovered simple secret would proud discovery equally ashamed taking long discover
2014,law concurrent programming,talk extends law programming  four law governing concurrent composition program operator associative commutative distributive union unit  sequential composition furthermore sequential concurrent composition distribute accordance exchange law permit implementation concurrency partial interleaving
2013,unifying semantics concurrent programming,four well-known method presenting semantics programming language denotational deductive operational algebraic essay present algebraic law structural feature class imperative programming language provide sequential concurrent composition illustrates way law consistent three semantic presentation language exposition combine simplicity generality postponing consideration possibly complex basic command particular programming language proof given hint easily reconstructed even aid machine
2013,generic model law programming,law programming collection judgment equality ordering computer program model law mathematical description execution program model proved satisfy law generic model one parameter adjusted property range different programming language differing implementation differing application way generic model serf basis unifying theory programming
2012,praise algebra,survey well-known algebraic law sequential programming extend le familiar law concurrent programming give algebraic definition hoare triple algebraic proof relevant law concurrent separation logic give provable concurrency law milner transition back/morgan refinement calculus dijkstras weakest precondition end section praise algebra carroll morgan master
2012,net model concurrent object behaviour,behaviour object allocated used computer program consists set event involving object occur around computer execution program object behaviour modelled occurrence net  event transition  arrow transition represent dependency event total behaviour program sum behaviour object allocates program  mathematically defined set possible behaviour possible environment execution object class similarly defined set possible behaviour possible object used possible program
2012,algebra concurrent design,summary form given introduce familiar algebraic law governing operator sequential concurrent composition design combined familiar operator propositional calculus resulting logic seems apply equally hardware design software design perhaps also planning design plan behaviour evolves space time
2012,algebra unifies operational calculus,survey well-known algebraic law sequential programming propose le familiar law concurrent programming basis law derive general calculus program execution basic judgment theory quintuple deduce rule algebraic reasoning general calculus specialised obtain familiar operational calculus structural operational semantics plotkin process calculus semantics milner reduction semantics evaluation context felleisen hieb natural semantics kahn algebra unifies calculus simpler calculus derived stronger put together
2011,concurrent kleene algebra foundation,concurrent kleene algebra offer two composition operator related weak version exchange law applied trace model program semantics one stand sequential execution concurrent execution program component introducing motivating concrete application investigate abstract  term primitive independence relation trace basis develop series richer algebra richest validates proof calculus program similar jones style rely/guarantee calculus basis abstract algebra finally reconstruct original trace model using notion atom lattice theory
2011,recovery block,give semantics brian randells recovery block show proved correct formalisation expressed wholly propositional logic
2011,locality exchange law concurrent process,paper study algebraic model concurrency light recent work concurrent kleene algebra separation logic establishes strong connection concurrency frame rule separation logic variant exchange law category theory investigate two standard model one us set trace state-based using assertion weakest precondition relate latter standard model heap partial function exploit power algebra unify model classify variation
2010,fine-grain concurrency,interested concurrent programming since  associated problem contributed failure largest software project managed moved academic career  hoped could find solution problem research quite quickly decided concentrate coarsegrained concurrency allow concurrent process share main memory interaction process confined explicit input output command simplification led eventually exploration theory communicating sequential process since joining microsoft research  plucked courage last look finegrain concurrency involving thread interleave access main memory fine granularity single instruction execution combining merit number different theory concurrency one paint relatively simple picture theory correct design concurrent system indeed picture great help conveying basic understanding paper present ongoing direction research pursuing colleague cambridgeboth microsoft research university computing laboratory copyright   car hoare
2010,csp retract cc,automaton theory provides two way defining automaton either transition system defining state event language set sequence  event engage many class automaton form definition proved equivalent example well-known isomorphism regular language finite deterministic automaton paper suggests  non-deterministic automaton  appropriate link transition system language may retraction rather isomorphisma pair automaton defined tradition cc transition system may compared pre-ordering based kind simulation bisimulation example weak strong barbed automaton defined tradition csp naturally ordered set inclusion language  variation ordering arise different choice basic event including example refusal divergence case characterise theory underlying transition system choice ordering treatment therefore wholly semantic independent syntax definition operator calculuswe put forward series retraction relating above-mentioned version csp corresponding cc transition model retraction injection  monotonic increasing idempotent  map node transition system source theory system saturated additional transition retraction defined transition rule style operational semantics proof use familiar technique co-induction often abbreviated encoding relational calculusthe aim paper contribute unification theory reactive system programming practical benefit may follow example justify method improve efficiency model checking based simulation furthermore show model checking transition network fit consistently theorem-proving tool reason directly specification design expressed term set sequence observable event
2010,unraveling card trick,one version gilbreath’s card trick deck card arranged series quartet quartet contains card suit quartet feature ordering suit example deck could repeating sequence spade heart club diamond order deck below{ } { } { q} { }{ k} { } { } { }{ } { j} { } { a}the deck cut two  half-decks possibly { } { } { q} { } { k} { } { } { } { } { j} { } { a}the order one half-decks reversed either half-deck could reversed pick smaller one ie first one reverse obtain { k} { } { q} { } { } two half-decks shuffled  riffle-shuffle one shuffle shown underlined card drawn second half-deck{ } { } { k} { }{ } { } { q} { j}{{ }} { } { } { a}the quartet shuffled deck displayed demonstrate quartet contains card suit turn inevitable matter original deck cut order two deck shuffled principle underlying card trick proved number way present argument series transformation demystify trick describe formalization
2010,differential static analysis opportunity application challenge,widely believed program analysis closely targeted need programmer program accompanied redundant documentation may include regression test suite api protocol usage code contract added largest redundant text previous version program difference successive version legacy program already use occupy programmer time although differential analysis form equivalence checking quite successful hardware design received much attention static program analysis communitythis paper briefly summarizes current state art differential static analysis software suggests number promising application although regression test generation often thought ultimate goal differential analysis highlight several application enabled differential static analysis includes equivalence checking semantic diffing differential contract checking summary validation invariant discovery better debugging speculate differential static analysis tool potential widely deployed developer toolbox despite fundamental stumbling block limit adoption static analysis
2010,testing proving hand-in-hand,motivating ideal lifetime’s scientific research program correctness achieved aid mathematical proof suggested turing floyd others proof would based decoration program assertion would proved true ever evaluated point written code long academic career regarded program testing main rival technology feared improvement practice testing would delay development application superior technology proof
2009,verified software initiative manifesto,n/a
2009,graphical model separation logic,graph used model control data flow among event occurring execution concurrent program treatment data flow cover shared storage external communication nevertheless law hoare jones correctness reasoning remain valid interpreted general model
2009,foundation concurrent kleene algebra,concurrent kleene algebra offer two composition operator one stand sequential execution concurrent execution  paper investigate abstract  law term independence relation concrete trace model algebra based moreover show interdependence basic property relation two law essential application algebra jones style rely/guarantee calculus finally reconstruct trace model abstract setting based notion atom lattice theory
2009,concurrent kleene algebra,concurrent kleene algebra offer next choice iteration operator sequential concurrent composition related inequational form exchange law show applicability algebra partially-ordered trace model program execution semantics demonstrate usefulness validating familiar proof rule sequential program  concurrent one  involves algebraic notion invariant exchange inequation strengthens equational distributivity law reasoning checked computer
2008,verification fine-grain concurrent program,intel announced future standard computer chip contain many processor operating concurrently shared memory use memory interleaved fine granularity individual memory access speed individual processor never significantly faster today continued increase performance therefore depend skill programmer exploiting concurrency multi-core architecture addition programmer avoid increased risk race condition non-determinism deadlock livelocks reduce risk propose theory correctness fine-grain concurrent program approach amalgamation number well-known well-researched idea including flowchart floyd assertion petri net process algebra separation logic critical region rely/guarantee reasoning idea applied combination design structured calculus correctness fine-grain concurrent program includes main feature structured concurrent programming language
2008,separation logic semantics communicating process,paper explores unification idea concurrent separation logic communicating sequential process extends separation logic operator separation time well separation space extends csp direction pi-calculus dynamic change alphabet achieved communication channel name separation exploited ensure channel still two end purpose exploration model simplest possible confined trace without refusal treatment sufficiently general facilitate extension standard technique sharing multiplexed channel heap state
2008,verified software theory tool experiment,ideal verified software long goal research computer science paper argues time ripe embark grand challenge project construct program verifier based sound complete theory programming evaluated experimental application representative sample useful computer software
2008,compensable transaction,concept compensable transaction embodied modern business workflow language like bpel article us concept box-structured petri net formalise definition compensable transaction standard definition structured program connective extended construct longer-running transaction shorter fine-grain one floyd-type assertion arc net specify intended property transaction component program correctness whole transaction therefore proved local reasoning
2007,ideal program correctness third computer journal lecture,ideal verified software long goal research computer science article argues time ripe embark grand challenge project construct program verifier based sound complete theory programming evaluated experimental application large representative sample useful computer softwarecomputer science owes existence invention stored-program digital computer derives continuously renewed inspiration constant stream new computer application still opened half century continuous reduction cost computer chip spectacular increase reliability performance capacity science programming made comparable advance discovery
2007,science engineering collusion culture,culture science engineering diametrically opposed along number dimension long-term/short-term idealism/compromise formality/ intuition certainty/risk management perfection/ adequacy originality/familiarity generality/specificity unification/diversity separation/amalgamation concern would expect two radically different culture collide yet technological advance modern era result collision collusion-in original sense fruitful interplay idea culture author illustrates point example research program verification research dependability system first aim development exploitation grand unified theory programming therefore share culture science second based practical experience project range important computer application share culture engineering collision culture would unexpected author suggests time come collusion author suggests need define interface across culture explicitly collaborate dependability research deliver  form library realistic domain model variety important common computer application domain model reusable pattern many subsequently conceived product product line includes mix informal formal description environment computer system network embedded concentrate interface computer system likely requirement preference community user practicing software engineer take relevant application domain model starting point new project project proposal specializes accord current environment current customer requirement domain model lik
2006,ever csp,original theoretical model communicating sequential process owed inspiration achievement milner scott dijkstra developed around time publication milners calculus communicating system ever csp diverge ccsthe esprit basic research action concur brought together proponent three original calculus concurrency acp cc csp hoped would develop unified calculus concur upon adoption ever faili would like share way thought question twenty five year ago since many excellent comparative study conducted result see theory best unified without assimilation distinctive feature compromise distinctive merit
2006,intelligent system formal method software engineering,last year technology formal description construction analysis validation software - based mostly logic formal reasoning - matured expect complement partly replace traditional software engineering method future formal method software engineering increasingly important application area intelligent system field outgrown area academic case study industry showing serious interest convincingly argue weve reached point solve problem formally verify industrial-scale software propose program verification computer science grand challenge deductive software verification core technology formal method describe recent dramatic change way perceived used another important base technique formal method besides software verification synthesizing software thats correct construction formally derived specification discus recent development trend area surprisingly efficient decision procedure satisfiability modulo theory problem recently emerged explain technique theyre important formal-methods tool look formal method industry perspective explain success microsoft research slam project developed verification tool device driver
2006,verified software repository step towards verifying compiler,verified software repository dedicated long-term vision future computer system justify trust society increasingly place would accompanied substantial reduction current high cost programming error incurred design development testing installation maintenance evolution retirement computer software important technical contribution vision verifying compiler tool-set automatically prof program always meet specification insofar formalised without even needing run challenge computing research  year current state art give ground hope may implemented foreseeable future achievement overall vision depend also continued progress research dependability software evolution envisaged ukcrc grand challenge project dependable system evolution verified software repository first step towards realisation long-term vision maintain develop evolving collection state-of-the-art tool together representative portfolio real program specification test evaluate develop tool contribute initially inter-working tool eventually integration promote transfer relevant technology industrial tool software engineering practice build recognised achievement practical formal development safety-critical computer application contribute international initiative verified software covering theory tool experimental validation
2006,ideal verified software,talk intended introduction afternoon discussion grand challenge problem acl community want invite address possibility even broadly based challenge directed towards scientific ideal verified software challenge bring together talent theorist tool-builders experimental scientist around world provide opportunity collaboration scientific competition many research community period fifteen year testable goal---the production automatic verification  million line useful code drawn many area computer application
2006,proving correctness highly-concurrent linearisable object,study family implementation linked list using fine-grain synchronisation approach enables greater concurrency correctness greater challenge classical coarse-grain synchronisation example demonstrative common design pattern lock coupling optimistic lazy synchronisation although highly concurrent prove linearisable safe correctly implement high-level abstraction proof illustrate power applicability rely-guarantee reasoning well limitation example paper establish benchmark challenge reasoning technique
2005,grand challenge computing research,major research challenge face world computing today match grandeur well-known challenge branch science article report exercise computing research community uk answer question includes summary outcome bcs-sponsored conference held newcastle-upon-tyne   march year
2005,comparing two approach compensable flow composition,web service composition emerging paradigm integration long running business process attracting interest industry term xml-based standard business description academy exploiting process description language key challenging aspect model orchestration workflow choreography exchanged message fault handling transactional integrity compensation mechanism recent proposal attempted mitigate explosion xml-constructs ad hoc standard careful selection small set primitive related aspect paper clarifies analogy difference two recent process description language one based interleaving trace semantics concurrent trace take advantage comparison characterise relate four different coordination policy compensating parallel process policy differ way abort process influence execution sibling process whether compensation distributed centralised
2005,linking theory concurrency,construct galois connection theory underlie cc  csp  project complete transition system cc onto exactly subset satisfies healthiness condition csp construction applies several variety calculus cc strong weak barbed simulation csp trace refinement failure refinement failures/divergence suggest challenge linking theory concurrency galois connection
2005,verifying compiler grand challenge computing research,idea program verification date back turing von neumann introduced concept assertion specification interface part program idea mechanical theorem proving date back leibniz explored practice modern computer mccarthy milner many others since proposal ’a program verifier’ combining two technology subject doctoral dissertation james c king submitted carnegie institute technology early attempt automatic program verification premature much progress made last thirty five year hardware capacity software technology verification suggest renewed challenge automatic verifying compiler could provide focus interaction cross-fertilisation advancement experimental evaluation technology interest conferenceperhaps concerted international effort may able meet challenge fifty year proposed jim king fifteen year left
2005,verified software theory tool experiment vision grand challenge project,summarythe ideal correct software long goal research computer science good theoretical understanding describe program workthis understanding already applied design development manual verification simple program moderate size used critical applicationsautomatic verification could greatly extend benefit technologythis paper argues time ripe embark international grand challenge project construct program verifier would use logical proof give automatic check correctness program submitted itprototypes program verifier based sound complete theory programming supported range program construction analysis tool entire toolset evaluated evolve experimental application large widely representative sample useful computer programsthe project provide scientific basis solution many problem programming error afflict builder user software todaythis paper start optimistic vision possible long-term future reliable programming argues scientific research play essential role reaching long-term goal suggests achievement accelerated major international research initiative modelled grand challenge specific measurable goal suggested measure one million line verified codeby definition consists executable program together specification design assertion etc together machine-checked proof program consistent documentation anticipate project would last ten year consume one thousand person-years skilled scientific effort drawn worldeach country contribute proportion effort benefit shared allthe paper concludes suggestion exploratory pilot project launch initiative call volunteer take first step project immediately conferencea possible first step revise improve paper generally agreed report goal method scientist wish engage project
2004,process algebra unifying approach,process algebra study system act react continuously environment model transition graph whose node represent state whose edge labelled name event interact environment trace behaviour process recorded sequence observable event process engages refinement defined inclusion trace refined process process refines simulation relation compare state well event definition two process start state related simulation engage event end state also related simulation bisimulation defined symmetric simulation similarity defined weakest simulation classical automaton theory transition graph deterministic given node one edge given label result trace refinement similarity coincide meaningresearch many year produced wide variety process algebra distinguished manner compare process usually form simulation form refinement paper aim unify study process algebra maintaining identity similarity trace refinement even non-deterministic system obviously unifying approach entirely dependent prior exploration diversity theory apply unbounded diversity real world aim unification inspire co-ordinate exploration yet diversity way detract value exploration
2004,towards verifying compiler,verifying compiler one prof mechanically program correct allowing run correctness program defined placing assertion strategic point program text particularly interface component recent enquiry among software developer microsoft discovered assertion already used widely program development practice main rôle test oracle detect programming error close possible place occurrence progress reliable software engineering currently supported programmer productivity tool conjecture developed exploit assertion various kind various way stage program development eventually assertion used widely original purpose establishing important aspect correctness large program however construction fully verifying compiler remains long-term challenge twenty-first century computing science
2004,trace semantics long-running transaction,long-running transaction interactive component distributed system must executed single atomic action principle interrupted fail middle must interleaved atomic action concurrently executing component system practice illusion atomicity long-running transaction achieved aid compensation action supplied original programmer transaction interactive familiar automatic technique check-pointing rollback longer adequate paper construct model long-running transaction within framework csp process algebra showing compensation orchestrated achieve illusion atomicity introduces method declaring process transaction declaring compensation case need rolled back committed familiar operator sequential composition redefined ensure necessary compensation called right order later failure make necessary technique designed work well highly concurrent distributed setting addition define angelic choice operation implemented speculative execution alternative judicious use improve responsiveness system face unpredictable latency remote communication many familiar property process algebra preserved new definition reasonable assumption correctness independence programmer-declared compensation
2004,stuck-free conformance,present novel refinement relation  cc process satisfies substitutability property conforms p environment p | stuck-free p | stuck-free stuck-freedom related csp notion deadlock discriminative taking orphan message asynchronous system account prove conformance precongruence cc process thereby supporting modular refinement distinguish conformance related preorders stable failure refinement csp refusal preorder cc implemented conformance checking new software model checker zing report used find error distributed program
2003,assertion personal perspective,assertion boolean formula placed program text place evaluation always true assertion strong enough express everything programmer either side interface need know program side even code written indeed assertion serve basis formal proof correctness complete program
2003,verifying compiler grand challange computing research,propose set criterion distinguish grand challenge science engineering many kind short-term long-term research problem engage interest scientist engineer example drawn computer science revive old challenge construction application verifying compiler guarantee correctness program running
2002,assertion modern software engineering practice,assertion boolean formula placed program text place evaluation always true assertion strong enough express everything programmer either side interface need know program side even code written indeed assertion serve basis formal proof correctness complete program
2002,assertion programming scientific theory engineering practice,assertion computer program logical formula  programmer expects evaluate true every occasion program control reach point written assertion used specify purpose program define interface major component early proponent assertion alan turing  suggested use establishing correctness large routine  bob floyd revived idea basis verifying compiler would automatically prove correctness program compiled reading paper became member small research school devoted exploring idea theoretical foundation top-down design methodology program development expect research influence industrial practice retirement academic life thirty year ahead beenin talk describe way assertion used microsoft programming practice mostly used test oracle detect effect program error close possible origin beginning exploited also program analysis tool even compiler optimisation code one purpose never actually used prove correctness program story presented case study way scientific research ideal accuracy correctness find unexpected application essentially softer approximative task engineering
2001,legacy,increasing proportion effort skilled programmer devoted servicing legacy software technique tool currently use tackle problem take good advantage  past research programming theory suggest new generation tool based concept principle developed basic research present future research directed currently outstanding challenge point illustrated example drawn personal experience show academic research education contribute industrial development production atmosphere mutual respect different allegiance timescales recognition convergence long-term goal
2001,growing use assertion,n/a
2000,hard act follow,n/a
2000,unifying theory healthiness condition,theory programming start complete boolean algebra specification defines healthiness condition exclude infeasibility implementation expressed algebraic law useful transformation optimisation design programming notation language must restricted preserving healthiness condition explored wide range programming paradigm including nondeterministic sequential parallel logical probabilistic case found single healthiness condition formalised construction due karoubi kleisli uniformity maintains paradigm single notion correctness throughout chain lead specification design program proved meet original specification
2000,algebraic derivation operational semantics,n/a
2000,legacy code,n/a
2000,assertion,assertion boolean formula written text program programmer asserts always true part program executed specie internal interface part program come follows software industry today assertion conditionally compiled test run program help detection diagnosis error alan turing first proposed assertion mean checking large routine rediscovered independently naur generalised snapshot floyd used assign meaning program floyd suggested internal assertion strong enough would constitute formal proof correctness complete program lecture summarise subsequent development idea describe practical impact
1999,linking theory probabilistic programming,paper present theory probabilistic programming based relational calculus series stage stage concentrate different smaller class program defined healthiness condition increasing strength stage show notation probabilistic language conserve healthiness condition operand every theory conserve definition recursion
1999,theory programming top-down bottom-up meeting middle,theory programming provides scientific basis programming practice lead predictable delivery program high quality top­down theory start specification intended behaviour program bottom­up theory start description program executed aim theory prove theorem  helpful design development compilation testing optimisation maintainance kind program mature theory presented bottom­up top-down fashion essentially law valid presentation
1999,trace model pointer object,object-oriented program  notoriously prone following kind error could lead increasingly severe problem presence taskingfollowing null pointer deletion accessible object failure delete inaccessible object interference due equality pointer inhibition optimisation due fear   type discipline object class great help avoiding error stronger protection may obtainable help assertion particularly invariant intended true call method update structure heap note introduces mathematical model language formulation assertion object pointer suggests graphical calculus  may help reasoning program correctness deal garbage-collected heap kind theory based trace model graph using idea process algebra development seek exploit analogy unifying principle
1999,algebra logic programming,declarative programming language two kind semantics abstract help reasoning specification correctness operational semantics determines manner program execution correct program reconcile abstract meaning concrete interpretation help present kind algebraic semantics logic programming list law equally valid predicate calculus standard depth-first strategy prolog alternative strategy breadth-first search share many law strategy shown special case general strategy tree searching three strategy defined lazy functional language haskell law proved standard algebraic reasoning law enrichment familiar categorical concept monad link monad explored  introduction earlier p
1999,semantics imprecise exception,modern superscalar microprocessor provide imprecise exception guarantee report exception would encountered straightforward sequential execution program exchange offer increased performance decreased chip area performance/precision tradeoff far much explored programming language level paper propose design imprecise exception lazy functional programming language haskell discus several design conclude imprecision essential language still enjoy current rich algebra transformation sketch precise semantics language extended exceptionsthe paper show extend haskell exception without crippling language compiler yet enough experience using new mechanism know whether strike appropriate balance expressiveness performance
1998,unifying theory programming,professional practice mature engineering discipline based relevant scientific theory usually expressed language mathematics mathematical theory programming aim provide similar basis specification design implementation computer program theory presented variety style including  denotational relating program specification observable property behaviour  algebraic providing equation inequations comparison transformation optimization design program  operational describing individual step possible mechanical implementation paper present simple theory sequential non-deterministic programming three style deriving presentation predecessor cyclic fashion mutual consistency assured
1997,unifying theory parallel programming,progress science involves constant interplay diversification unification diversification extends boundary science cover new wider range phenomenon successful unification reveals range experimentally validated theory particular case general principle cycle continues general principle reveals direction experimental investigation paper suggests time come attempt unifying classification theory parallel programming ideally provide common basis reasoning specification correctness design optimising program algebraic transformation implementing range technology variety machine architecture satisfy need wide range application
1996,unifying theory  personal statement,n/a
1996,logic engineering design,n/a
1996,software get reliable without proof,surveying current software engineering practice paper reveals technique employed achieve reliability little different proved effective branch modern engineering rigorous management procedure design inspection review quality assurance based wide range targeted test continuous evolution removal error product already widespread use defensive programming among form deliberate over-engineering formal method proof play small direct role large scale programming provide conceptual framework basic understanding promote best current practice point direction future improvement
1996,role formal technique past current future software get reliable without proof extended abstract
1996,mathematical model computing science,mathematical equation predicate used physical science formalise describe predict observable behaviour isolatable fragment real world phenomenon interest computing science advantage formalised mathematical predicate scientiic way result concurrency often modelled conjunction  non-determinism disjunction locality existential quan-tiication correctness logical implication  thesis illustrated application variety level granularity scale abstraction hardware switching combinational sequential circuitry   programming  procedural  parallel  logical  paradigm major achievement modern science demonstrate link phenomenon diierent level abstraction generality quark particle atom molecule right star galaxy  entire universe le grand scale computer scientist establish link every implementation higher level concept term lower   link also formalised equation general predicate describing relationship observation made diierent level abstraction  clariication assist understanding structure entire scientific discipline
1995,sequential calculus,paper present algebraic calculus like relational calculus reasoning sequential phenomenon provides common foundation several proposed model concurrent reactive system clearly differentiated relational calculus absence general converse operation permit treatment temporal logic within sequential calculus
1995,unification theory challenge computing science,unification theory long-standing goal natural science modern physic offer spectacular paradigm achievement structure modern mathematics also determined great unifying theory — topology algebra like ideal goal shared researcher student theoretical computing science
1994,editorial,n/a
1994,provably correct system,goal provably correct system project  develop mathematical basis development embedded real-time computer system survey paper introduces specification language verification technique four level development requirement definition control design transformation system architecture program design transformation program compilation real-time program conventional processor compilation program hardware
1994,hardware software closing gap,study computing science split early stage branch dealing separately hardware software corresponding split later professional specialisation paper explores essential unity overlap two branch basic concept occam taken simple example high-level programming language notation may translated law programming machine code conventional machine almost identical transformation produce network gate flip-flop constitute hardware design insight exploited hybrid system implemented partly hardware partly software tram-standard printed circuit board called harp constructed application link transputer shared memory commercial field programmable gate array prospect application discussed
1993,normal form approach compiler design,paper demonstrates reduction normal form help design correct compiler dijkstras guarded command language compilation strategy transform source program series algebraic manipulation normal form describes behaviour stored-program computer transformation eliminates high-level language construct favour lower-level construct correctness compiler follows correctness algebraic transformation
1993,algebra operational semantics,n/a
1993,algebra model,science make progress constructing mathematical model deducing observable consequence testing experiment successful theoretical model later taken basis engineering method code practice design reliable useful product model play similar central role progress practical application computing sciencea model computational paradigm start choice carrier set potential direct indirect observation made computational process particular process modelled subset observation give rise process composition modelled relating observation composite process component indirect observation play essential role composition algebraic property composition operator derived aid simple theory set relation feasibility checked mapping operational modela model constructed family set easily adapted calculus design total correctness specification given arbitrary set containing observation permitted required product expressed clearly possible aid full power mathematics logic product meet specification potential observation form subset permitted observation principle requires envisaged failure mode product modelled indirect observation avoidance proved specification component composed mathematically operator component permit top-down proof correctness design even implementation begin algebraic property reasoning helpful throughout development non-determinism seen problem rather part solution
1992,model synchronous switching circuit theory correctness,following bryant  algorithm given translating switching circuit design program simulates dynamic behavior theory assertion based dijkstra  unity  developed formalize specification hardware circuit design establish correctness combinational sequential circuit taken account n-mos c-mos latter turn much simpler
1992,program predicate,computer program identified strongest predicate describing every relevant observation made behaviour computer executing program programming language subset logical mathematical notation restricted product described language automatically implemented computer notation enjoy number elegant algebraic property used optimizing program efficiency specification predicate describing permitted observation program may expressed greatest clarity taking advantage whole language logic mathematics program p meet specification iff  proof implication may use classical method mathematics logic point illustrated design small language includes assignment condition non-determinism recursion input output concurrency 
1991,transputer occam personal story,paper tell story development twentyfive year idea communicating sequential process one subtle useful facility guarded choice appears alt command occam subtlety clarified usefulness increased understanding relevant simple algebraic law based mathematical research conducted oxford abstraction provided mathematics secret versatility occam reliably efficiently implemented multiprogramming multiprocessing hardware combination  conjectured occam programming paradigm remain efficient reliable generalpurpose sharedstore multiprocessor future
1991,calculus duration,purpose calculus duration reason design requirement time-critical system without explicit mention absolute time distinctive feature reasoning integral duration different state within given interval first section introduces running example leakage gas burner second section defines axiomatises proposed calculus extension interval temporal logic third section applies problem described introduction fourth section briefly survey alternative calculus
1991,pre-adjunctions order enriched category,category theory offer unified mathematical framework study specification program variety style procedural functional concurrent one way different language may treated uniformly generalising definition standard categorical concept paper reproduce generalised theory analogue standard theorem isomorphism outline application programming language
1991,theory derivation combinational c-mos circuit design,paper show propositional logic may used reason synchronous combinational switching circuit implemented c-mos develops simple formalism theory describing predicting behaviour build calculus design driven proof obligation design philosophy software introduced  thereby extended certain kind hardware design prior knowledge hardware assumed reader useful  motivation example picture may found  many problem described paper solved one
1990,fixed point increasing function,e increasing function partial order fixed point functional composition  point fixed e true form parallel composition  using least upper bound v partial order fact may useful case fixed point computed iteration arbitrary mixture sequential parallel composition
1990,let make model abstract,n/a
1990,theory synchrony asynchrony,loosely-coupled  data flow network often contrasted tightly-coupled  system present csp unified theory type system deduce algebraic law relating theory may useful design implementation system part take advantage paradigm 
1990,theory conjunction concurrency,general condition specification concurrent system expressed conjunction specification component process explored lattice-theoretic fixed-point theorem increasing function proved example application several area computing science given consequence drawn design concurrent algorithm high-level programming language fine-grained concurrent computer architectures< >
1989,categorical semantics programming language,n/a
1989,variety programming language,n/a
1988,law occam programming,one attractive feature occam large number memorable algebraic law exist relating program investigate law discovering normal form while-free program show completely characterise language semantics
1988,partial correctness c-mos switching circuit exercise applied logic,possibility extending logical method recommended design software design hardware particular synchronous switching circuit implemented cmos explored objective design network known construction thing go wrong circuit designed way examined application technique discussed< >
1987,law programming,complete set algebraic law given dijkstras nondeterministic sequential programming language iteration recursion explained term scott domain theory fixed point continuous functionals calculus analogous weakest precondition suggested aid deriving program specification
1987,overview formal method program design
1987,algebraic specification proof distributed recovery algorithm,algebraic specification given algorithm recovery catastrophe deterministic process second version algorithm also includes check-points algorithm formulated notation communicating sequential process  proof correctness conducted wholly application algebraic law 
1987,weakest prespecification,n/a
1987,prespecification data refinement,data refinement concrete data type replaces abstract data type used design algorithm system  present two method calculating weakest specification operation concrete data type specification corresponding abstract operation together single simulation relation  specifies correspondence two type method proved sound  complete nondeterministic procedural programming language slightly powerful dijkstras  operation  represented relation significant use made prespecification postspecification 
1986,specification-oriented semantics communicating process,summarya process p satisfies specification every observation make behaviour p allowed use idea process correctness starting point developing specific form denotational semantics process called specification — oriented semantics approach serf uniform framework generating relating series increasingly sophisticated denotational model communicating processesthese model differ underlying structure observation influence number representable language operator induced notion process correctness safety property treated model sophisticated model also permit proof certain liveness property important feature model special hiding operator abstract internal process activity allows large process composed hierarchically network smaller one way proof whole constructed proof component also show consistency denotational model wrt simple operational semantics based transition make internal process activity explicit
1986,data refinement refined,consider original work hoare jones data refinement light dijkstra smyths treatment nondeterminism milner park definition simulation communicating system two proof method suggested hope simpler general current use proved individually sufficient correctness refinement together necessary proof method employed derive weakest specification implementation abstract specification
1985,couple novelty propositional calculus,n/a
1985,mathematics programming,hold principle construction computer program mathematical activity like solution differential equation program derived specification mathematical insight calculation proof using algebraic law simple elegant elementary arithmetic
1984,theory communicating sequential process,mathematical model communicating sequential process given number interesting useful property stated proved possibility nondetermimsm fully taken account
1984,programming sorcery science,professional programming practice based underlying mathematical theory follow tradition better-established engineering discipline success come improved education
1984,program executable predicate,computer program identified strongest predicate describing every relevant observation made behaviour computer executing program programming language subset logical mathematical notation 
1983,axiomatic basis computer programming reprint,paper attempt made explore logical foundation computer programming use technique first applied study geometry later extended branch mathematics involves elucidation set axiom rule inference used proof property computer program example given axiom rule formal proof simple theorem displayed finally argued important advantage theoretical practical may follow pursuance topic
1983,communicating sequential process reprint,paper suggests input output basic primitive programming parallel composition communicating sequential process fundamental program structuring method combined development dijkstras guarded command concept surprisingly versatile use illustrated sample solution variety familiar programming exercise
1983,complete model communicating process,previous paper hoare give axiom proof rule communicating process provide calculus total correctness paper give explicit definition communicating process predicate former axiom proof rule become theorem proved using explicit definition defining predicate powerful proof rule reasoning process le often useful construction implementation process using partial recursive function given
1983,specification simplified network service csp,specification simplified network service given cspbecause specification service notoriously difficult especially pleasing case problem decomposed several easily achieved sub-specifications decomposition greatly improves credibility overall specification
1981,calculus total correctness communicating process,process communicates environment process syncronized output input named channel current state process defined sequence message passed along channel set message may next passed channel process satisfies assertion assertion time true possible state process present calculus proving process satisfies assertion describing intended behaviour following construct axiomatised output input simple recursion disjoint parallelism channel renaming connection hiding process chaining nondeterminism conditional alternation mutual recursion calculus illustrated proof number simple buffering protocol
1981,partial correctness communicating sequential process,n/a
1981,ambiguity insecurity pascal,ambiguity insecurity programming language pascal discussed
1980,theory nondeterminism,construction described take arbitrary set machine arbitray set test arbitrary relation machine test defining machine pas test produce domain specification retract lattice set test  domain nondeterministic machine  retract lattice set machine  two domain isomorphic simple condition ensure ω-algebraicfunctions domain may defined equivalently either transformation ndms  transformation specification  condition realism function formulated
1979,semantics nondeterminism concurrency communication,n/a
1978,communicating sequential process,paper suggests input output basic primitive programming parallel composition communicating sequential process fundamental program structuring method combined development dijkstras guarded command concept surprisingly versatile use illustrated sample solution variety familiar programming exercise
1978,property predicate transformer
1978,software engineering keynote address,paper argues recent progress development sound programming methodology lead u ignore difficult aspect engineering future pay attention quality design accuracy implementation
1978,semantics nondeterminism concurrency communication extended abstract,n/a
1977,fast fourier transform free tear,many description fast fourier transform exist literature several appeal matrix concept kronecker multiplication paper show essential simplicity algorithm reasoning behind however deal case number point exact power 
1976,parallel programming axiomatic approach,paper develops idea expounded  distinguishes number way using parallelism including disjoint process competition cooperation communication case axiomatic proof rule given
1976,quasiparallel programming,paper describes simone extension pascal provides quasiparallel programming facility simula  without class reference language intended suitable design testing simulation operating system algorithm illustrated simple example suitable project material course operating system simple restricted efficient implementation described suggested language might suitable general simulation purpose example general job shop simulation given
1975,matrix reduction - efficient method,paper describes efficient method reduction binary matrix arise school time-tabling problem development described john lion generalized adapted fit complete timetabling process use compact data representation efficient processing technique take fuller advantage possible available previous knowledge matrix designed structured program readily coded reader high level low level programming language choice practical test method shown good basis realistic timetabling algorithm
1975,recursive data structure,power convenience programming language may enhanced certain application permitting treelike data structure defined recursion paper suggests pleasing notation structure declared processed give axiom specify property suggests efficient implementation method show recursive data structure may used represent another data type example set discus two way significant gain efficiency made selective updating structure give relevant proof rule hint implementation example show certain range application symbol manipulation efficiently programmed without introducing low-level concept reference high-level programming language
1975,proof correctness data representation,powerful method simplifying proof program correctness suggested new light shed problem function side-effects
1975,structure operating system,paper describes use class inner concept simula  express multi-level structure operating system comparison drawn compile-time checking run-time protection
1974,consistent complementary formal theory semantics programming language,summarythis paper present comparative study different method formal description programming language method applied simple realistically usable programming language abstract definition proved consistent relative concrete one
1974,monitor operating system structuring concept,paper develops brinch-hansens concept monitor method structuring operating system introduces form synchronization describes possible method implementation term semaphore give suitable proof rule illustrative example include single resource scheduler bounded buffer alarm clock buffer pool disk head optimizer version problem reader writer
1974,optimization store size garbage collection,n/a
1973,axiomatic definition programming language pascal,axiomatic definition method proposed reference  extended applied define meaning programming language pascal  whole language covered exception real arithmetic go statement
1973,structured paging system,principle practice structured programming expounded illustrated relatively small example  systematic method construction parallel algorithm also suggested  paper attempt extend structured programming method program intended operate parallel environment namely paging system implementation virtual store design decision motivated consideration cost effectivenessthe purpose paging system taken sharing main backing store computer among number user making unpredictable demand upon way user concerned whether information stored given time main backing store sake definiteness backing store taken sectored drum system could readily adapted device design rely particular paging hardware implementable reasonable combination hardware software furthermore presuppose particular structure virtual store  provided user program
1973,general conservation law queueing discipline,n/a
1972,program proving jump function,summaryproof method adequate wide range computer program expounded   paper develops method suitable program containing function certain kind jump method illustrated proof useful efficient program table lookup logarithmic search
1972,proof correctness data representation,summarya powerful method simplifying proof program correctness suggested new light shed problem function side-effects
1972,proof structured program sieve eratosthenes,paper illustrates method constructing program together proof structuring program two level abstraction proof abstract algorithm may completely separated proof concrete representation way overall complexity proof kept within reasonable bound
1972,incomputability,n/a
1971,proof program find,proof given correctness algorithm “find” first informal description given purpose program method used systematic technique described constructing program proof process coding way prevent intrusion logical error proof termination treated separate exercise finally relating general programming methodology drawn
1971,proof recursive program quicksort,paper give proof useful non-trivial program quicksort  first general algorithm described informally next rigorous informal proof correctness coded program given finally formal method introduced drawn possibility enlisting mechanical aid proof process
1969,axiomatic basis computer programming,paper attempt made explore logical foundation computer programming use technique first applied study geometry later extended branch mathematics involves elucidation set axiom rule inference used proof property computer program example given axiom rule formal proof simple theorem displayed finally argued important advantage theoretical practical may follow pursuance topic
1968,data structure two-level store,n/a
1966,contribution development algol
1963,elliott algol input/output system,description method specifying input output algol program run national-elliott  elliott  digital computer
1962,quicksort,description given new method sorting random-access store computer method compare favourably known method speed economy storage ease programming certain refinement method may useful optimization inner loop described second part paper
1962,report elliott algol translator,n/a
1961,algorithm 63 partition,n/a
1961,algorithm 65 find,n/a
1961,algorithm 64 quicksort,n/a
