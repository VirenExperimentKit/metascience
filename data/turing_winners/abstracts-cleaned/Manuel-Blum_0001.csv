2017,towards human computable password,interesting challenge cryptography community design authentication protocol simple human execute without relying fully trusted computer propose several candidate authentication protocol setting human user receive assistance semi-trusted computer - computer store information performs computation correctly provide confidentiality scheme use semi-trusted computer store display public challenge c_i^k human user memorizes random secret mapping  {z}_d authenticates computing response f sequence public challenge f{z}_d^k {z}_d function easy human evaluate prove statistical adversary need sample m={}{n^{s}} challenge-response pair recover  security parameter depends two key property f lower bound generalizes recent  feldman et al  proved analogous  special case d= obtain  apply general hypercontractivity theorem  lower bound statistical dimension distribution challenge-response pair induced f  statistical dimension lower bound apply arbitrary function f{z}_d^k {z}_d  application propose family human computable password function f_{k_k_} user need perform k_+k_+ primitive operation  show = {k_+ /} scheme prove forging password equivalent recovering secret mapping thus human computable password scheme maintain strong security guarantee even adversary observed user login many different account
2016,cybernetics mathematician mind,n/a
2015,publishable humanly usable secure password creation schema,human compute his/her head powerful adversary cannot infer answer question define model human computation measure security motivated special case password creation propose collection well-defined password-generation method show password generation method humanly computable well-defined extent machine uncrackable proof security posit password generation method public human privately chosen seed adversary observed input-output pair besides application password generation proposed human usability model  application
2013,naturally rehearsing password,introduce quantitative usability security model guide design password management scheme — systematic strategy help user create remember multiple password way security proof cryptography based complexity-theoretic assumption  quantify usability introducing usability assumption particular password management relies assumption human memory eg user follows particular rehearsal schedule successfully maintain corresponding memory assumption informed research cognitive science tested empirically given rehearsal requirement user’s visitation schedule account use total number extra rehearsal user would remember password measure usability password scheme usability model lead u key observation password reuse benefit user reducing number password user memorize importantly increasing natural rehearsal rate password also present security model account complexity password management multiple account associated threat including online offline plaintext password leak attack observing current password management scheme either insecure unusable present shared cue — new scheme underlying secret strategically shared across account ensure rehearsal requirement satisfied naturally simultaneously providing strong security construction us chinese remainder theorem achieve competing goal
2013,gotcha password hackers!,introduce gotchas  way preventing automated offline dictionary attack user selected password gotcha randomized puzzle generation protocol involves interaction computer human informally gotcha satisfy two key property  puzzle easy human solve  puzzle hard computer solve even random bit used computer generate final puzzle --- unlike captcha  main theorem demonstrates gotchas used mitigate threat offline dictionary attack password ensuring password cracker must receive constant feedback human mounting attack finally provide candidate construction gotchas based inkblot image construction relies usability assumption user recognize phrase originally used describe inkblot image --- much weaker usability assumption previous password system based inkblot required user recall phrase exactly conduct user study evaluate usability gotcha construction also generate gotcha challenge encourage artificial intelligence security researcher try crack several password protected scheme
2010,understanding inductive inference,talk different kind understanding including especially provided deductive inductive inference example drawn galileo kepler fermat application given physicist’s problem inferring law nature restricted case inferring sequence sloane’s encyclopedia integer sequenceswhile much theory understanding deductive inference relatively little understanding process inductive inference inductive inference hypothesizing hopefully inferring law physic observation data kepler coming three law planetary motiononce law place deductive inference used derive consequence uncovers much understanding physicsthis talk define inductive inference state open problem give application relatively simpler still largely unexplored task namely inferring large natural class algorithmically generated integer sequence includes  sloane’s encyclopedia integer sequence
2007,improving image search phetch,keyword-based image search engine hindered lack proper labeling image index many case label agree content image since image generally indexed filename surrounding text web page another popular approach image search content based image retrieval suffers gap available low level data semantic need user search overcome problem suggest human annotation image natural language description end present phetch engaging multiplayer game allows people attach accurate explanatory text caption arbitrary image web people play game fun side effect collect valuable information applied towards improving image retrieval furthermore game also used novel application
2006,peekaboom game locating object image,introduce peekaboom entertaining web-based game help computer locate object image people play game entertainment value side effect playing collect valuable image metadata pixel belong object image collected data could applied towards constructing accurate computer vision algorithm require massive amount training testing data currently available peekaboom played thousand people spent  hour day playing thus far generated million data point addition purely utilitarian aspect peekaboom example new emerging class game bring people together leisure purpose also exist improve artificial intelligence game appeal general audience providing answer problem computer cannot yet solve
2006,verbosity game collecting common-sense fact,address problem collecting database common-sense fact using computer game informally common-sense fact true statement world known human milk white touching hot metal hurt etc several effort devoted collecting common-sense knowledge purpose making computer program intelligent effort however succeeded amassing enough data manual process entering fact tedious therefore introduce verbosity novel interactive system form enjoyable game people play verbosity fun side effect playing collect accurate common-sense knowledge verbosity example game brings people together leisure also collect useful data computer science
2006,improving accessibility web computer game,image web present major accessibility issue visually impaired mainly majority proper caption paper address problem attaching proper explanatory text description arbitrary image web end introduce phetch enjoyable computer game collect explanatory description image people play game fun side effect game play collect valuable information given image world wide web phetch output correct annotation collected data applied towards significantly improving web accessibility addition improving accessibility phetch example new class game provide entertainment exchange human processing power essence solve typical computer vision problem hci tool alone
2004,telling human computer apart automatically,lazy cryptographer ai
2003,captcha using hard ai problem security,introduce captcha automated test human pas current computer program can’t pas program high success captcha used solve unsolved artificial intelligence  problem provide several novel construction captchas since captchas many application practical security approach introduces new class hard problem exploited security purpose much like research cryptography positive impact algorithm factoring discrete log hope use hard ai problem security purpose allows u advance field artificial intelligence introduce two family ai problem used construct captchas show solution problem used steganographic communication captchas based ai problem family imply win-win situation either problem remain unsolved way differentiate human computer problem solved way communicate covertly channel
2001,secure human identification protocol,one interesting important challenge cryptologic community providing secure authentication identification unassisted human range protocol secure identification require various form trusted hardware software aimed protecting privacy financial asset verify identity securely don’t don’t trust smart card palmtop laptopin paper provide definition believe reasonable goal secure human identification demonstrate existing solution meet reasonable definition finally provide solution demonstrate feasibility security condition attached definition impractical use human
1997,software reliability via run-time result-checking,review field result-checking discussing simple checker self-correctors argue checker could profitably incorporated software aid efficient debugging enhanced reliability consider modify traditional checking methodology make appropriate use real-time real-number computer system particular suggest checker allowed use stored randomness allowed generate preprocess store random bit prior run-time use information repeatedly series run-time check case study checking general real-number linear transformation  present simple checker us stored randomness self-corrector particularly efficient stored randomness employed
1997,program error detection/correction turning pac learning perfect learning abstract,computational learning theory concerned developing “scratch” probably approximately correct  algorithm solve given computational problem program error detection /correction concerned transforming program — — correct instance program correct instance two approach together enable one generate perfect program scratch goal talk describe latter error detection/correction algorithm work encourage integration learning theory
1996,reflection pentium bug,review field result-checking suggest extended methodology enforcing hardware/software reliability thereby formulate vision self-monitoring hardware/software whose reliability augmented embedded suite run-time correctness checker particular suggest embedded checker correctors may employed safeguard arithmetic error bedeviled intel pentium microprocessor specify checker correctors suitable monitoring multiplication division functionality arbitrary arithmetic processor seamlessly correcting erroneous output may occur reason lifetime chip
1995,problem sorting burnt pancake,“pancake problem” well-known open combinatorial problem recently shown application parallel processing given stack n pancake arbitrary order different size goal sort size-ordered configuration largest pancake bottom smallest top allowed sorting operation “spatula flip” spatula inserted beneath pancake pancake spatula lifted replaced reverse order problem bound f minimum number flip required worst case sort stack n pancake equivalently seek bound number prefix reversal necessary sort list n element bound ofandwere shown gate papadimitriou  paper consider traditional variation problem pancake two sided  must sorted size-ordered configuration every pancake burnt side let g number flip required sort n “burnt pancakes” find upper bound hold n ⩾  consider conjecture difficult case sorting n burnt pancake −in configuration pancake proper size order individual pancake upside present algorithm sorting −in inflips c small constant thereby establishing bound ofunder conjecture furthermore longstanding upper bound f also improved tounder conjecture
1995,designing program check work,program correctness checker algorithm checking output computation given program instance program run checker certifies whether output program instance correct paper defines concept program checker design program checker specific carefully chosen problem class fp function computable polynomial time problem fp checker presented paper include sorting matrix rank gcd also applies method modern cryptography especially idea probabilistic interactive proof design program checker group theoretic computationstwo structural theorem proven one characterization problem checked theorem establishes equivalence class problem whenever one problem class checkable problem class checkable
1995,contribution theoretical computer science,n/a
1995,self-correcting function field transcendental degree,use algebraic field extension theory find self-correctors broad class function many function whose translation contained function field finite degree extension scalar field satisfy polynomial identity transformed self-correctors function efficiently corrected way simpler different function actually computed essential feature program self-correcting among function present self-correctors many rational expression xe x  sin  wed many rational expression x g x  mapping integer finite field many rational expression xlog h   mapping finite field realsthe new tool presented extended abstract useful theory program self testing/correcting furthermore may yield new  complexity theory previous work self-testing polynomial important application pcp protocol proved hardness approximating max-snp problem
1994,checking correctness memory,extend notion program checking include program alter environment particular consider program store retrieve data memory model consider allows checker small amount reliable memory checker presented sequence request  data structure must reside large unreliable memory view data structure controlled adversary want checker perform operation input sequence using reliable memory unreliable data structure error operation structure detected checker high probabilitywe present checker various data structure prove lower bound logn amount reliable memory needed checker wheren size structure lower bound information theoretic apply various assumption also show time-space tradeoff checking random access memory generalization coherent function
1994,program result-checking theory testing meet test theory,review field result-checking discussing simple checker self-correctors argue checker could profitably incorporated software aid efficient debugging reliable functionality consider modify traditional checking methodology make appropriate use real-time real-number computer system particular suggest checker allowed use stored randomness ie allowed generate pre-process store random bit prior run-time use information repeatedly series run-time check case study checking general real-number linear transformation  present simple checker us stored randomness self-corrector particularly efficient stored randomness allowed< >
1994,matching nut bolt,describe procedure may helpful disorganized carpenter mixed pile bolt nut want find corresponding pair bolt nut procedure us  ability construct efficiently highly expanding graph problem considered given collection n bolt distinct width n nut - correspondence nut bolt goal find bolt corresponding nut comparing nut bolt nut nut bolt bolt objective minimize number operation kind  problem randomized algorithm similar quicksort main result n^o time deterministic algorithm based expander graph matching bolt nut
1993,self-testing/correcting application numerical problem,suppose someone give u extremely fast program p call black box compute function f trust p work correctly self-testing/correcting pair f allows u  estimate probability p ≠ φ x randomly chosen  input x compute f correctly long p faulty average furthermore   take time slightly original running time p present general technique constructing simple program self-testing/correcting pair variety numerical function including integer multiplication modular multiplication matrix multiplication inverting matrix computing determinant matrix computing rank matrix integer division modular exponentiation polynomial multiplication
1993,program result checking new approach making program reliable,program result checking concerned designing program check work example solving equation x result-checking program would substitute x back equation make sure answer obtained correct many way check  theory say constitutes good check good check example redo computation without change second time recomputation may uncover intermittent hardware fault uncover software fault discovery elimination software fault principal goal work talk discus concept result checking give several example outline basic theory
1993,designing program check work abstract,designing program check work professor manuel blurn department eec uc berkeley international computer science institute berkeley california abstract student engineer programmer expected check work computer program several reason  computer hardware almost never make error -- fails recognize programmer do!  program hard enough write without also write program checker -- price increased confidence!  clear notion constitutes good checker indeed student engi-neers cautioned check work rarely informed make proce-dure good -- sort problem computer science able solve! view lack correctness check program oversight program bug could perfectly well caught check talk urge program written check work outline promising rigorous approach study fascinating new area
1993,checking approximate computation real,paper provides first systematic investigation checking approximate numerical computation subset real case approximate checking challenging exact checking problem conditioning ie measure sensitivity output slight change input presence approximate ion parameter foil direct transformation many exact checker approximate setting furthermore approximate checking real complicated lack nice finite field property existence samplable distribution invariant addition multiplication scalar overcome problem using technique testing checking similar distinct distribution using function random downward self-reducibility property taking advantage small variance sum independent identically distributed random variable provide approximate checker variety computation including matrix multiplication linear system solution matrix inversion computation determinant also present approximate version beigel trick extend approximate linear self tester/corrector  trigonometric selftester/corrector  general computation 
1992,towards computational theory statistical test extended abstract,author initiate computational theory statistical test loosely speaking algorithm statistical test reject negligible fraction string statistical test universal class algorithm reject  string rejected algorithm class consider existence efficiency universal statistical test various class statistical test also consider relation ensemble passing statistical test particular complexity ensemble indistinguishable uniform algorithm complexity  refer relatively simple statistical test < >
1992,universal statistical test,n/a
1991,inductive inference unsolvability,shown many different problem degree unsolvability among problem arethe inductive inference problem infer limit index recursive function f presented f ffthe recursive index problem decide limit index total recursive functionthe zero nonvariant problem decide limit recursive function f presented f f f value unequal zero infinitely many argumentsfinally shown unsolvable problem strictly easier halting problem
1991,noninteractive zero-knowledge,paper investigates possibility disposing interaction prover verifier zero-knowledge proof share beforehand short random stringwithout assumption proven noninteractive zero-knowledge proof exist number-theoretic language efficient algorithm knownif deciding quadratic residuosity  computationally hard shown np-complete language satisfiability also posse noninteractive zero-knowledge proof
1991,program checking,n/a
1989,reversing train turn century sorting problem,paper study reversing train puzzle proposed sam loyd near turn century concern version puzzle described recently k dewdney scientific american train locomotive n car must entirely reversed using short spur line attached main track efficiency solution determined summing car total distance moved car distance measured car length present algorithm accomplishing task
1989,program result checking adaptive program cryptographic setting,theory program result checking introduced blum allows one check program p correctly computes function f input x checker may use p output input help check p x f x setting p always assumed xed program whose output input x function p x extend theory check program p return result input x may depend previous question asked p call checker work program adaptive checker consider case adaptive program supposedly computes f running several noninteracting machine design adaptive checker work constant number independent noninteracting program also consider following cryptographic scenario user want evaluate function f input x using program p running another machine checking user trust program correct additional requirement user want let machine know little information possible x question asked program p example user may want program able learn input size abadi feigenbaum kilian beaver feigenbaum call program satis e constraint private checker case adaptive checking consider case program supposedly computes f several noninteracting machine design private checker work constant number independent noninteracting program adaptive private checker given general technique work variety numerical problem including integer multiplication modular multiplication matrixmultiplica tion mod function integer division modular exponentiation polynomial multiplication
1989,program correctness one test,n/a
1988,proving security chosen cyphertext attack,relevance zero knowledge cryptography become apparent recent year paper advance theory showing interaction zero-knowledge proof replaced sharing common short random string advance find immediate application construction first public-key cryptosystem secure chosen ciphertext attackour solution though yet practical theoretical significance since existence cryptosystems secure chosen ciphertext attack famous long-standing open problem field
1988,non-interactive zero-knowledge application extended abstract,show interaction zero-knowledge proof replaced sharing common short random string use result construct first public-key cryptosystem secure chosen ciphertext attack
1987,generic oracle oracle class extended abstract,paper examine various complexity issue relative oracle generic set order determine natural conjecture issue generic oracle  viewed parallel random oracle   two many way related shall exhibit equivalent looking computation relative generic oracle way better reflection computation without oracle example whereas adding random oracle allows deterministic polynomial-time machine solve problem bpp adding generic oracle help solve recursive problem faster could solved without oracle generic set first introduced cohen tool proving independence  set theory  recursion theoretic property also explored depth example see   related work using forcing and/or generic set tool oracle construction found     however knowledge first knowledge first thorough examination complexity relative generic oracle
1986,independent unbiased coin flip correlated biased source-a finite stae markov chain,von neumann trick simulating anabsolutely unbiased coin biased one thistoss biased coin twice getting       occur go back step  else call  ah  since pr=prpr=pr output unbiased example      httpeter elia give algorithm generate independent unbiased sequence ofhs andts nearly achieves entropy one-coin source algorithm excellent certain difficulty arise trying use  generate bit expected linear time markov chainin paper return original one-coin von neumann scheme show extend generate independent unbiased sequence ofhs andts markov chain expected linear time give wrong right way two algorithm b use simple von neumann trick every state markov chain differ time choose announce coin flip timing crucial
1986,simple unpredictable pseudo-random number generator,two closely-related pseudo-random sequence generator presented ${ / p}$generator input p prime output quotient digit obtained dividing  p $x^  n$generator input n $x_ $  output $b_ b_ b_  $ $b_i = {{parity}}$ $x_{i + } = x_i^  n$from short seed generator efficiently produce long well-distributed sequence moreover generator computationally hard problem core first generator sequence however completely predictable  whereas second certain intractability assumption unpredictable precise sense second generator additional interesting property knowledge $x_ $ n notp q one generate sequence forward above-mentioned intractability assumption one generate sequence backwards additional knowledge p q one generate sequence backwards one even jump point sequence property $x^  n$generator promise many interesting application eg public-key cryptography use generator practice analysis needed various property sequence period analysis begun
1984,generate cryptographically strong sequence pseudo-random bit,give set condition allow one generate  unpredictable bitsbased condition present general algorithmic scheme constructing polynomial-time deterministic algorithm stretch short secret random input long sequence unpredictable pseudo-random bitswe give implementation scheme exhibit pseudo-random bit generator efficient strategy predicting next output bit better  chance easily transformable equally efficient algorithm solving discrete logarithm problem particular discrete logarithm problem cannot solved probabilistic polynomial time probabilistic polynomial-time algorithm guess next output bit better flipping coin head guess  tail guess 
1984,efficient probabilistic public-key encryption scheme hide partial information,paper introduces first probabilistic public-key encryption scheme combine following two propertiesperfect secrecy respect polynomial time eavesdropper message space polynomial time bounded passive adversary tapping line compute partial information message encoding unless factoring composite integer probabilistic polynomial time efficiecy compare favorably deterministic rsa public-key cryptosystem encoding decoding time bandwidth expansion  security system propose also based assumption rsa function intractable maintaining cost encoding decoding data expansion implementation may advantage practice
1984,independent unbiased coin flip correlated biased source finite state markov chain,von neumann trick generating absolutely unbiased coin biased one  toss biased coin twice getting        occur go back step  else  call  h  since p = p*p = p output unbiased example      /spl ioarr/ h peter elia give algorithm generate independent unbiased sequence h t nearly achieves entropy one-coin source algorithm excellent certain difficulty arise trying use  generate bit expected linear time markov chain paper return original one-coin von neumann scheme show extend generate independent unbiased sequence h t markov chain expected linear time give right wrong way two algorithm b use simple von neumann trick every state markov chain differ time choose announce coin flip timing crucial
1983,exchange secret key,protocol presented whereby two adversary may exchange secret though neither trust secret prime factor publicly announced composite number two adversary exchange secret bit bit fea
1983,reducibility among protocol,recently considerable attention given designing provably secure cryptographic protocol three basic problem studied exchange secret contract signing certified mail several protocol proposed problem solution diverse nature secure different assumption different probability cheating require different number message exchange consequently need investigate underlying relationship problem paper study reducibilities among problem ie protocol one problem transformed protocol another problem preserving  operating condition
1983,exchange secret key extended abstract,protocol presented whereby two adversary may exchange secret though neither trust secret prime factor publicly announced composite number two adversary exchange secret bit bit fear cheat sending “junk”bits solve problem show two prove bit delivered bit good application suggested electronic business transaction signing contract sending certified electronic mail
1982,coin flipping telephone - protocol solving impossible problem,alice bob want flip coin telephone  bob would like tell alice head hear alice  say go    im flipping coin    lost!coin-flipping special way done serious purpose indeed prove indispensable tool protocol designer whenever protocol requires one two adversary say alice pick sequence bit random whenever serf alices interest best pick sequence bit random coin-flipping  defined achieves desired goal guarantee bob alice pick sequence bit random bit  bob flip head otherwise guarantee alice bob know sequence bit flipped hercoin-flipping already proved useful solving number problem thought impossible mental poker certified mail exchange secret certainly prove useful tool solving problem well
1982,comparison two pseudo-random number generator,want pseudo-random sequence generator ideally would like pseudo-random sequence generator quickly produce short seed long sequence  appear every way generated successive flip fair coin
1982,generate cryptographically strong sequence pseudo random bit,give set condition allow one generate  unpredictable bitsbased condition present general algorithmic scheme constructing polynomial-time deterministic algorithm stretch short secret random input long sequence unpredictable pseudo-random bitswe give implementation scheme exhibit pseudo-random bit generator efficient strategy predicting next output bit better  chance easily transformable equally efficient algorithm solving discrete logarithm problem particular discrete logarithm problem cannot solved probabilistic polynomial time probabilistic polynomial-time algorithm guess next output bit better flipping coin head guess  tail guess 
1981,complexity testing whether graph superconcentrator,n/a
1981,coin flipping telephone,two party trust wish agree result coin toss conversing telephone new protocol solves problem proposed compared previous protocol 
1980,equivalence free boolean graph decided probabilistically polynomial time,n/a
1978,power compass maze easier search graph,n/a
1977,capability finite automaton 2 3 dimensional space,paper describes two algorithm threading unknown finite directed eulerian maze algorithm performed traveling robot whose control finite-state automaton assumed vertex circular list outgoing edge item list called exit algorithm put one exit vertex scan pebble pebble used simple robot traffic signal allow traverse eulerian cycle maze directed graph  g simple algorithm performs edge traversal advanced algorithm traverse every edge three time let dout out-degree vertex v algorithm use vertex v local memory size
1975,toward mathematical theory inductive inference,intelligence test occasionally require extrapolation effective sequence  produced easily discernible algorithm paper investigate theoretical capability limitation computer infer sequence design turing machine principle extremely powerful purpose place upper bound capability machine would better
1974,almost everywhere complex recursive function,let h recursive function partial recursive function &psgr io  h-complex every program &psgr requires h step compute &psgr infinitely many input &khgr stringent notion &psgr ae  h-complex &psgr ae h-complex every program &psgr requires h step compute &psgr finitely many input &khgr two definition h-complex function yield theorem although possible prove every io h-complex recursive function io h-complex possible prove every ae h-complex recursive function ae h-complex similarly recursive function io h-complex proven recursive function ae h-complex cannot proven construction almost everywhere complex recursive function appears much difficult construction infinitely often complex recursive function found “natural” example recursive function requiring polynomial time finitely many input shown single example moderately ae complex recursive function one obtain ae complex recursive function
1973,time bound selection,number comparison required select i-th smallest n number shown linear function n analysis new selection algorithm—pick specifically  n comparison ever required bound improved extreme value new lower bound requisite number comparison also proved
1973,complexity property recursively enumerable set,important goal complexity theory see characterize partial recursive function recursively enumerable set given complexity property term involve notion complexityas contribution goal provide characterization effectively speedable speedable levelable  set purely recursive theoretic term introduce notion subcreativeness show every program computing partial recursive function f effectively speeded infinitely many integer graph f subcreativein addition order cast light concept effectively speedable speedable levelable set show maximal set levelable  effectively speedable exhibit set levelable strong sense yet effectively speedable
1973,inductive inference recursion theoretic approach,several situation trying le model one arises standard iq test person given finite sequence integer asked produce next integer sequence another provided following grossly simplified view one aspect physic consider physicist trying find law explain growing body experimental data data presented set pair  x description particular experiment eg high energy physic experiment description  obtained eg particle produced respective property law describing phenomenon essentially algorithm computing function f = inductive inference machine request obtain data form pair  use look algorithm computes  f example arise grammatical inference pattern recognition etc paper develops inductive inference along line solomonoff  gold  feldman  new distinguishes work attempt characterize set function identified inductive inference machine process discovered  inductive inference machine considerably powerful previously thought possible
1972,linear time bound median computation,new upper lower bound presented maximum number comparison f required select i-th largest n number upper bound found analysis new selection algorithm linear function n f ≤ n/ < n  ≤ ≤ n lower bound shown deductively f ≥ n+min +  −   ≤ ≤ n− case computing median fn ≥ n/ − 
1971,effective procedure speeding algorithm,paper concerned nature speedup let f recursive function show effective procedure going algorithm f significantly faster algorithm f hand effective proced
1968,tape reversal complexity hierarchy,n/a
1967,size machine,paper method recursive function theory used study size  machine positive result study show remarkable degree relative size two machine independent particular way machine size measured another result suggests order program economical size programming language must powerful enough compute arbitrary general recursive function rather restricted subset primitive recursive function finally kind speedup theorem proved curiously independent whether measure complexity size number step taken machine compute function
1967,machine-independent theory complexity recursive function,number step required compute function depends general type computer used choice computer program input-output code nevertheless  obtained paper general nearly independent consideration function exhibited requires enormous number step computed yet “nearly quickest” program program function matter ingeniously designed may take practically many step nearly quickest program different function exhibited property matter fast program may computing function another program exists computing function much faster
1967,automaton 2-dimensional tape,paper explains approach problem pattern recognition serial computer rudimentary theory vision presented lie within framework automaton theory goal classify type pattern recognized automaton scan finite -dimensional tape example would like know automaton decide whether given pattern tape form connected region although solved number problem failed solve connectedness problem paper merely begin describe action automaton higher dimension goal generalize theory presented make applicable wide variety pattern-recognizing machine
